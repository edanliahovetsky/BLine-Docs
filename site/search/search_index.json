{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BLine","text":"<p>BLine is an open-source path generation and tracking suite designed for holonomic drivetrains (swerve, mecanum, etc.) made by students for students. It's built around simplicity and performance in time-constrained environments where quick iteration and rapid empirical testing prove advantageous.</p> <p>BLine offers the advantages of simplicity, easy tunability, and excellent real time performance while performing at the same (or potentially better) level as other autonomous solutions. </p> <p></p>"},{"location":"#the-bline-suite","title":"The BLine Suite","text":"<p>BLine consists of two main components that work together:</p>"},{"location":"#gui-visual-path-planning","title":"GUI - Visual Path Planning","text":"<p>BLine-GUI is a visual path planning interface for designing and editing autonomous paths with real-time simulation preview.</p> <p>Go to GUI Documentation \u2192</p>"},{"location":"#library-path-following","title":"Library - Path Following","text":"<p>BLine-Lib is a Java library for FRC robots that loads paths and provides the path-following algorithm for your drivetrain.</p> <p>Go to Library Documentation \u2192</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation \u2014 Get BLine set up on your system</li> <li>Quick Start \u2014 Create and follow your first path</li> <li>Core Concepts \u2014 Understand path elements, constraints, and parameters</li> <li>API Reference \u2014 Full Java API documentation</li> </ul>"},{"location":"#external-resources","title":"External Resources","text":"<ul> <li>BLine-Lib on GitHub</li> <li>BLine-GUI on GitHub</li> <li>Full Javadoc</li> <li>Chief Delphi Discussion Thread</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>BLine has been validated through extensive testing with a WPILib physics simulation, utilizing Theta* for initial pathfinding and an Artificial Bee Colony (ABC) optimizer to benchmark the system against PathPlanner.</p> <p>Quantitative Results from randomized Monte Carlo trials:</p> <ul> <li>97% reduction in path computation time</li> <li>66% reduction in cross-track error at waypoints</li> <li>Negligible 2.6% decrease in total path tracking time compared to PathPlanner</li> </ul> <p>Read the Full White Paper</p>"},{"location":"#license","title":"License","text":"<p>BLine is released under the BSD 3-Clause License.</p>"},{"location":"common-issues/","title":"Common Issues","text":"<p>Common issues and solutions when working with BLine paths. This guide covers the most frequently encountered problems and provides actionable steps to resolve them.</p>"},{"location":"common-issues/#robot-overshoots-at-turns","title":"Robot Overshoots at Turns","text":"<p>Causes:</p> <ul> <li>Velocity too high for handoff radius</li> <li>Handoff radius too small</li> </ul> <p>Solutions:</p> <ol> <li>Add velocity constraint before the turn</li> <li>Increase handoff radius at that element</li> <li>Add an intermediate TranslationTarget to break up the path</li> </ol>"},{"location":"common-issues/#robot-hesitates-at-waypoints","title":"Robot Hesitates at Waypoints","text":"<p>Causes:</p> <ul> <li>Handoff radius too small</li> <li>Velocity constraint too aggressive</li> </ul> <p>Solutions:</p> <ol> <li>Increase handoff radius</li> <li>Review velocity constraints</li> </ol>"},{"location":"common-issues/#path-takes-longer-than-expected","title":"Path Takes Longer Than Expected","text":"<p>Causes:</p> <ul> <li>Constraints too conservative</li> <li>Too many elements</li> <li>End tolerances too tight</li> </ul> <p>Solutions:</p> <ol> <li>Review constraint values</li> <li>Simplify path with fewer elements</li> <li>Loosen end tolerances if precision isn't critical</li> </ol>"},{"location":"common-issues/#robot-doesnt-face-correct-rotation","title":"Robot Doesn't Face Correct Rotation","text":"<p>Causes:</p> <ul> <li>Missing rotation target</li> <li>Profiled rotation causing slow transition</li> <li>Rotation controller P too low</li> </ul> <p>Solutions:</p> <ol> <li>Add RotationTarget or Waypoint with desired rotation</li> <li>Try non-profiled rotation for immediate rotation change</li> <li>Tune rotation controller gains</li> </ol>"},{"location":"usage-tips/","title":"Usage Tips","text":"<p>Best practices and recommendations for getting the most out of BLine.</p>"},{"location":"usage-tips/#constraint-tuning","title":"Constraint Tuning","text":""},{"location":"usage-tips/#max-translational-velocity-is-key","title":"Max Translational Velocity is Key","text":"<p>The max translational velocity constraint is the primary ranged constraint recommended for most use cases. It is the most effective method for counteracting overshoot at sharp turns\u2014other than increasing the handoff radius, which reduces path precision.</p> <p>By limiting velocity before tight corners, the robot can decelerate in time and follow the intended path more accurately.</p> <pre><code>Path.PathConstraints constraints = new Path.PathConstraints()\n    .setMaxVelocityMetersPerSec(\n        new Path.RangedConstraint(4.0, 0, 2),   // Fast on straight sections\n        new Path.RangedConstraint(1.5, 3, 4)    // Slow before sharp turn\n    );\n</code></pre>"},{"location":"usage-tips/#balancing-handoff-radius-and-velocity","title":"Balancing Handoff Radius and Velocity","text":"Scenario Solution Robot overshoots turns Lower velocity OR increase handoff radius Robot hesitates at waypoints Increase handoff radius OR increase velocity Robot cuts corners Decrease handoff radius OR lower velocity Path precision matters Smaller handoff radius + lower velocity <p>Avoid the Worst Case</p> <p>If the radius is too small, the robot may overshoot and miss the handoff zone entirely at high velocities\u2014this causes erratic path behavior and is the worst-case scenario. Conversely, if the handoff radius is too large, the robot will switch targets too early, causing path instability.</p> <p>Smooth Turns: Add More Elements</p> <p>For smoother, more accurate navigation through turns, try adding a few extra TranslationTargets or Waypoints along the curve. This approach lets the robot follow the desired path more naturally\u2014without needing aggressive velocity constraints or oversize handoff radii. More elements create a gentler, better-controlled trajectory through each bend.  Just be sure not to oversaturate your paths and keep them as sparse as possible.</p>"},{"location":"usage-tips/#pid-tuning","title":"PID Tuning","text":""},{"location":"usage-tips/#tune-at-maximum-velocities","title":"Tune at Maximum Velocities","text":"<p>Critical</p> <p>When tuning the translation and rotation PID controllers, stress-test your controller gains at maximum robot velocity and acceleration for both translation and rotation.</p> <p>If you limit max acceleration after tuning your controllers, or increase max allowable velocity beyond what was used during tuning, you will likely experience:</p> <ul> <li>Overshoot when reaching the path endpoint</li> <li>Unexpected behavior during path following</li> </ul> <p>Always tune your controllers within the full operating range of velocities and accelerations that your path constraints allow.</p>"},{"location":"usage-tips/#tuning-order","title":"Tuning Order","text":"<p>The PID controllers should be tuned in the following order: translation, rotation, and finally cross-track. </p>"},{"location":"usage-tips/#translation-controller","title":"Translation Controller","text":"<p>The translation controller minimizes total path distance remaining.</p> <p>Controller Instability</p> <p>Avoid using the PID integral term for the translation controller. Using the integral term will cause translation controller instability. Integral term use in other controllers (Rotation and Cross-Track) is fine. </p> <p>Starting gains: P = 5.0, I = 0.0, D = 0.0</p>"},{"location":"usage-tips/#rotation-controller","title":"Rotation Controller","text":"<p>Minimizes error in holonomic heading (rotation).</p> <p>Starting gains: P = 3.0, I = 0.0, D = 0.0</p>"},{"location":"usage-tips/#cross-track-controller","title":"Cross-Track Controller","text":"<p>Keeps the robot on the line between waypoints or translation targets. It should be used to reduce path deviation in longer path segments over time, rather than on sharp turns. </p> <p>Controller Instability</p> <p>Be wary of cross-track controller over-tuning (where the controller overpowers the translation controller). An over-tuned cross-track controller will cause undesirable behavior around turns, especially during high velocities. </p> <p>Starting gains: P = 2.0, I = 0.0, D = 0.0</p>"},{"location":"usage-tips/#path-design","title":"Path Design","text":""},{"location":"usage-tips/#use-translationtargets-for-path-shaping","title":"Use TranslationTargets for Path Shaping","text":"<p>Don't overuse Waypoints. If you just need the robot to pass through a point without a specific rotation, use a TranslationTarget instead:</p> <pre><code>// Good: Only specify rotation where it matters\nnew Path(\n    new Path.Waypoint(start, Rotation2d.fromDegrees(0)),      // Face forward at start\n    new Path.TranslationTarget(2.0, 3.0),                      // Just pass through\n    new Path.TranslationTarget(4.0, 3.5),                      // Path shaping\n    new Path.Waypoint(scoringPosition, Rotation2d.fromDegrees(180))  // Face target\n);\n</code></pre>"},{"location":"usage-tips/#use-rotationtargets-for-mid-segment-rotation","title":"Use RotationTargets for Mid-Segment Rotation","text":"<p>When you need to rotate while driving but don't need an extra waypoint:</p> <pre><code>new Path(\n    new Path.Waypoint(start, Rotation2d.fromDegrees(0)),\n    new Path.RotationTarget(Rotation2d.fromDegrees(90), 0.5),  // Rotate at midpoint\n    new Path.Waypoint(end, Rotation2d.fromDegrees(90))\n);\n</code></pre>"},{"location":"usage-tips/#single-element-paths-for-simple-moves","title":"Single-Element Paths for Simple Moves","text":"<p>Don't overcomplicate simple movements. A single Waypoint is valid:</p> <pre><code>// Simple drive-to-position\nPath simpleMove = new Path(\n    new Path.Waypoint(new Translation2d(3.0, 2.0), Rotation2d.fromDegrees(45))\n);\n</code></pre> <p>Paths Run to Completion</p> <p>BLine paths cannot be stopped midway through execution. If you need the robot to stop partway through a route, break it into separate Path objects:</p> <pre><code>Commands.sequence(\n    pathBuilder.build(toFirstScore),     // Drive to scoring position\n    new ScoreCommand(),                  // Stop to score\n    pathBuilder.build(toPickup),         // Drive to pickup location\n    new IntakeCommand()                  // Stop to intake\n);\n</code></pre>"},{"location":"usage-tips/#autonomous-performance","title":"Autonomous Performance","text":""},{"location":"usage-tips/#pre-orient-swerve-modules","title":"Pre-Orient Swerve Modules","text":"<p>For optimal autonomous start, pre-orient your swerve modules toward the initial path direction before the match begins:</p> <pre><code>// During disabled periodic or auto init\nPath firstPath = new Path(\"firstAutoPath\");\nRotation2d initialDirection = firstPath.getInitialModuleDirection();\ndriveSubsystem.setModuleOrientations(initialDirection);\n</code></pre> <p>This prevents the micro-deviations that occur when modules need to rotate during the initial acceleration.</p>"},{"location":"usage-tips/#use-pose-reset-wisely","title":"Use Pose Reset Wisely","text":"<p>The <code>withPoseReset()</code> option resets odometry to the path's starting pose. Use this for:</p> <ul> <li>First path in autonomous: Ensures odometry matches expected starting position</li> <li>After significant odometry drift: Reset to a known position</li> </ul> <pre><code>// Builder with pose reset enabled\npathBuilder.withPoseReset(driveSubsystem::resetPose);\n</code></pre> <p>Don't use pose reset for every path\u2014only when starting from a known position.</p>"},{"location":"usage-tips/#workflow-recommendations","title":"Workflow Recommendations","text":""},{"location":"usage-tips/#choose-your-workflow","title":"Choose Your Workflow","text":"Workflow Best For GUI + Lib + JSON Visual path design, iteration, easy adjustments JSON + Lib Teams comfortable editing JSON directly Code Only Dynamic paths, generated paths, full code control"},{"location":"usage-tips/#iterate-quickly","title":"Iterate Quickly","text":"<p>BLine is designed for rapid iteration:</p> <ol> <li>Design paths in GUI or JSON</li> <li>Test on hardware</li> <li>Adjust constraints and positions</li> <li>Repeat</li> </ol>"},{"location":"usage-tips/#use-the-simulation-for-quick-checks","title":"Use the Simulation for Quick Checks","text":"<p>The GUI simulation provides immediate feedback, but remember its limitations:</p> <ul> <li>Good for: Rough timing estimates, path flow validation, constraint effects</li> <li>Not accurate for: Exact timing, real drivetrain dynamics, PID behavior</li> </ul>"},{"location":"usage-tips/#event-triggers","title":"Event Triggers","text":"<p>Coming Soon</p> <p>Built-in event trigger support is a planned feature and will be added in a future release.</p> <p>Currently, BLine does not support event triggers built into paths. However, you can replicate trigger-like functionality using WPILib commands:</p>"},{"location":"usage-tips/#using-waituntil-for-trigger-behavior","title":"Using WaitUntil for Trigger Behavior","text":"<pre><code>// Trigger an action when the robot passes a certain point\nCommands.sequence(\n    Commands.parallel(\n        pathBuilder.build(myPath),\n        Commands.waitUntil(() -&gt; {\n            // Check if robot has passed x = 3.0 meters\n            return driveSubsystem.getPose().getX() &gt; 3.0;\n        }).andThen(new IntakeCommand())\n    )\n);\n</code></pre>"},{"location":"usage-tips/#using-deadlines-with-path-progress","title":"Using Deadlines with Path Progress","text":"<pre><code>// Run intake while following path, then score\nCommands.sequence(\n    Commands.deadline(\n        pathBuilder.build(scoringPath),\n        new IntakeCommand()  // Runs until path completes\n    ),\n    new ScoreCommand()\n);\n</code></pre>"},{"location":"usage-tips/#checking-path-progress","title":"Checking Path Progress","text":"<p>For more precise triggering, access the path follower's current state:</p> <pre><code>// Using getter methods on the FollowPath command\nFollowPath followCommand = (FollowPath) pathBuilder.build(myPath);\n\nCommands.parallel(\n    followCommand,\n    Commands.waitUntil(() -&gt; followCommand.getCurrentSegmentIndex() &gt;= 2)\n        .andThen(new PrepareScoreCommand())\n);\n</code></pre>"},{"location":"usage-tips/#why-no-second-alignment-routine","title":"Why No Second Alignment Routine?","text":"<p>Unlike time-parameterized path followers, BLine typically doesn't require a separate alignment routine after paths complete.</p> <p>Why other tools often need it:</p> <ul> <li>Time-parameterized tracking can finish \"early\" if the robot falls behind</li> <li>Controller tuning affects endpoint accuracy</li> <li>Robot may not be precisely positioned when path completes</li> </ul> <p>Why BLine doesn't:</p> <ul> <li>The translation controller minimizes distance to the endpoint, not time</li> <li>The robot continues driving until within tolerance, regardless of how long it takes</li> <li>No penalty for \"falling behind\"\u2014the greedy algorithm simply continues toward the target</li> </ul> <p>This means you can typically chain path commands directly without intermediate alignment steps.</p>"},{"location":"concepts/constraints/","title":"Path Constraints","text":"<p>Path constraints are critical for ensuring proper robot motion and preventing overshooting during element handoff. When the robot approaches a translation target at high speed without appropriate velocity limits, it may overshoot the handoff radius and exhibit erratic behavior. Properly configured constraints ensure smooth transitions between path elements.</p>"},{"location":"concepts/constraints/#constraint-types","title":"Constraint Types","text":"<p>BLine supports six constraint types that can be applied to paths:</p> Constraint Unit Description Max Translational Velocity m/s Maximum speed the robot can travel Max Translational Acceleration m/s\u00b2 Maximum acceleration for translation Max Rotational Velocity deg/s Maximum angular speed for holonomic rotation Max Rotational Acceleration deg/s\u00b2 Maximum angular acceleration for rotation End Translation Tolerance m How close the robot must be to the final position to finish End Rotation Tolerance deg How close the robot must be to the final rotation to finish"},{"location":"concepts/constraints/#global-constraints","title":"Global Constraints","text":"<p>Global constraints define default velocity/acceleration limits and tolerances for all paths. You can set them in two ways:</p>"},{"location":"concepts/constraints/#option-a-using-configjson-for-json-based-workflows","title":"Option A: Using config.json (for JSON-based workflows)","text":"<p>Create a <code>config.json</code> file in <code>src/main/deploy/autos/</code>:</p> <pre><code>{\n    \"default_max_velocity_meters_per_sec\": 4.5,\n    \"default_max_acceleration_meters_per_sec2\": 12.0,\n    \"default_max_velocity_deg_per_sec\": 540,\n    \"default_max_acceleration_deg_per_sec2\": 860,\n    \"default_end_translation_tolerance_meters\": 0.03,\n    \"default_end_rotation_tolerance_deg\": 2.0,\n    \"default_intermediate_handoff_radius_meters\": 0.2\n}\n</code></pre>"},{"location":"concepts/constraints/#option-b-setting-in-code-for-code-only-workflows","title":"Option B: Setting in Code (for code-only workflows)","text":"<p>Set global constraints programmatically in your robot initialization:</p> <pre><code>Path.setDefaultGlobalConstraints(new Path.DefaultGlobalConstraints(\n    4.5,    // maxVelocityMetersPerSec\n    12.0,   // maxAccelerationMetersPerSec2\n    540,    // maxVelocityDegPerSec\n    860,    // maxAccelerationDegPerSec2\n    0.03,   // endTranslationToleranceMeters\n    2.0,    // endRotationToleranceDeg\n    0.2     // intermediateHandoffRadiusMeters\n));\n</code></pre>"},{"location":"concepts/constraints/#in-the-gui","title":"In the GUI","text":"<p>Global constraints are configured in Settings \u2192 Robot Config. These serve as defaults when no path-specific or ranged constraint is set.</p>"},{"location":"concepts/constraints/#path-specific-constraints","title":"Path-Specific Constraints","text":"<p>Override global constraints for individual paths using <code>PathConstraints</code>:</p> <pre><code>Path.PathConstraints slowConstraints = new Path.PathConstraints()\n    .setMaxVelocityMetersPerSec(2.0)\n    .setMaxAccelerationMetersPerSec2(1.5)\n    .setMaxVelocityDegPerSec(180.0)\n    .setMaxAccelerationDegPerSec2(360.0)\n    .setEndTranslationToleranceMeters(0.02)\n    .setEndRotationToleranceDeg(1.0);\n\n// Create path with custom constraints\nPath slowPath = new Path(\n    slowConstraints,\n    new Path.Waypoint(new Translation2d(1.0, 1.0), new Rotation2d(0)),\n    new Path.TranslationTarget(new Translation2d(2.0, 2.0)),\n    new Path.Waypoint(new Translation2d(3.0, 1.0), new Rotation2d(Math.PI))\n);\n</code></pre>"},{"location":"concepts/constraints/#ranged-constraints","title":"Ranged Constraints","text":"<p>Ranged constraints allow different limits for different sections of a path\u2014essential for slowing down before tight turns or precision maneuvers.</p>"},{"location":"concepts/constraints/#defining-ranged-constraints","title":"Defining Ranged Constraints","text":"<p>Each ranged constraint is defined by:</p> <ul> <li><code>value</code>: The constraint value (velocity, acceleration, etc.)</li> <li><code>start_ordinal</code>: The first element index this constraint applies to (inclusive)</li> <li><code>end_ordinal</code>: The last element index this constraint applies to (inclusive)</li> </ul>"},{"location":"concepts/constraints/#ordinal-indexing","title":"Ordinal Indexing","text":"<p>Important: Separate Ordinal Counters</p> <p>Translation and rotation ordinals are tracked separately:</p> <ul> <li>Translation ordinal increments for each <code>TranslationTarget</code> and each <code>Waypoint</code></li> <li>Rotation ordinal increments for each <code>RotationTarget</code> and each <code>Waypoint</code></li> </ul> <p>This means a <code>Waypoint</code> (which contains both translation and rotation) increments both counters, while standalone <code>TranslationTarget</code> and <code>RotationTarget</code> elements only increment their respective counter.</p> <p>Example ordinal assignment:</p> Path Element Translation Ordinal Rotation Ordinal Waypoint (start) 0 0 TranslationTarget 1 \u2014 RotationTarget (t_ratio=0.5) \u2014 1 TranslationTarget 2 \u2014 Waypoint (end) 3 2 <p>When the path follower processes each element, it checks if any ranged constraint applies by testing:</p> <pre><code>startOrdinal &lt;= currentOrdinal &amp;&amp; endOrdinal &gt;= currentOrdinal\n</code></pre> <p>If a constraint matches, that value is used; otherwise, the global default is applied.</p>"},{"location":"concepts/constraints/#multiple-ranged-constraints","title":"Multiple Ranged Constraints","text":"<p>Paths can have multiple ranged constraints of the same type, allowing fine-grained control over different path sections. The first matching constraint (in array order) is used for each element.</p>"},{"location":"concepts/constraints/#json-example","title":"JSON Example","text":"<pre><code>{\n    \"path_elements\": [...],\n    \"constraints\": {\n        \"max_velocity_meters_per_sec\": [\n            { \"value\": 4.5, \"start_ordinal\": 0, \"end_ordinal\": 1 },\n            { \"value\": 1.5, \"start_ordinal\": 2, \"end_ordinal\": 3 }\n        ],\n        \"max_velocity_deg_per_sec\": [\n            { \"value\": 540, \"start_ordinal\": 0, \"end_ordinal\": 3 }\n        ],\n        \"end_translation_tolerance_meters\": 0.03,\n        \"end_rotation_tolerance_deg\": 2.0\n    }\n}\n</code></pre>"},{"location":"concepts/constraints/#code-example","title":"Code Example","text":"<pre><code>Path.PathConstraints constraints = new Path.PathConstraints()\n    .setMaxVelocityMetersPerSec(\n        new Path.RangedConstraint(4.5, 0, 1),   // Fast approach (ordinals 0-1)\n        new Path.RangedConstraint(1.5, 2, 3)    // Slow precision (ordinals 2-3)\n    )\n    .setMaxVelocityDegPerSec(\n        new Path.RangedConstraint(540, 0, Integer.MAX_VALUE)  // Apply to all\n    );\n</code></pre>"},{"location":"concepts/constraints/#visualizing-in-gui","title":"Visualizing in GUI","text":"<p>When you click on a ranged constraint's slider in the GUI, a green overlay highlights the affected path segments on the canvas. This shows exactly where the constraint will apply during path execution.</p> <p></p> <p>Start Ordinal Behavior</p> <p>A ranged constraint that includes the starting element will affect all robot motion leading into that element. For example, if your robot doesn't begin at the first path element (e.g., it's placed mid-field), a velocity constraint starting at ordinal 1 will limit the robot's speed as it travels toward the first waypoint.</p>"},{"location":"concepts/constraints/#how-constraints-affect-path-following","title":"How Constraints Affect Path Following","text":"<p>During path execution, <code>FollowPath</code> retrieves constraints for each element via <code>getPathElementsWithConstraints()</code>. The <code>ChassisRateLimiter</code> then enforces these limits by:</p> <ol> <li>Capping the commanded velocity to the current element's max velocity</li> <li>Limiting acceleration between cycles based on the current element's max acceleration</li> <li>Applying these limits separately to translational and rotational motion</li> </ol> <p>This ensures the robot respects velocity limits when approaching handoff radii, preventing overshoot and enabling precise element transitions.</p>"},{"location":"concepts/design-philosophy/","title":"Design Philosophy","text":"<p>BLine takes a fundamentally different approach to path tracking compared to traditional B\u00e9zier-based solutions like PathPlanner and Choreo. This page explains the rationale behind BLine's polyline architecture and when it excels.</p>"},{"location":"concepts/design-philosophy/#why-polylines","title":"Why Polylines?","text":""},{"location":"concepts/design-philosophy/#computational-efficiency","title":"Computational Efficiency","text":"<p>A direct improvement over PathPlanner and Choreo is computational efficiency and simplicity when creating simple paths.</p> <p>BLine does not need to precompute or discretize a B\u00e9zier trajectory into finite timestamps before the controller can follow the path. The path gets passed to the tracking controller immediately after creation, which provides loop cycle time gains for real-time teleop applications.</p> <p>This means you don't have to do any pre-computing as you might with B\u00e9zier trajectories. Of course, for pre-baked paths there's no difference\u2014the majority of computation happens during path creation regardless of the tool.</p> <p>Performance Results</p> <p>Validation testing demonstrated a 97% reduction in path computation time compared to PathPlanner.</p>"},{"location":"concepts/design-philosophy/#ease-of-controller-tuning","title":"Ease of Controller Tuning","text":"<p>The BLine tracking controller achieves good (if not better) results with less hassle. Tuning a time-parameterized PID controller to follow curved paths (B\u00e9zier or otherwise) can be difficult, especially for newer teams.</p> <p>Common issues with time-parameterized tracking:</p> <ul> <li>Over-tuned gains easily cause erratic behavior and jittering</li> <li>Under-tuned gains cause the robot to fall behind during acceleration</li> <li>Problems are exacerbated when the drivetrain isn't perfectly tuned</li> <li>Makes it harder to push a chassis to its true max acceleration and velocity limits</li> <li>Teams historically run a second profiled PID alignment routine after paths end to overcome tracking and early finish challenges</li> </ul> <p>BLine avoids these issues simply by the nature of its PID controller setpoint: the path's endpoint. By having the translation controller minimize total path distance remaining:</p> <ul> <li>Controller output is high at the start and properly tapers off at the end</li> <li>User-defined acceleration and velocity limits ensure the robot properly utilizes chassis acceleration</li> <li>The robot hits max velocity irrespective of drivetrain or tracking controller tuning</li> </ul> <p>Quick Tuning</p> <p>The tuning of BLine's translation PID controller is only critical at the very end of path tracking, where the robot must decelerate and stop. This domain is far more manageable compared to the time-parameterized approach.</p> <p>In testing, a good translational controller config was achieved in around 5 minutes of tuning.</p>"},{"location":"concepts/design-philosophy/#forgiving-performance","title":"Forgiving Performance","text":"<p>There's no large performance penalty for under-tuning\u2014the difference between optimally and sub-optimally tuned controllers is only noticeable at the very end of the robot's motion, making the tracking controller very forgiving.</p> <p>In contrast, a time-parameterized controller's response is apparent along the entire path, and poorly tuned chassis or gains are noticeable across the robot's entire motion, making sub-optimal tuning less forgiving.</p>"},{"location":"concepts/design-philosophy/#path-simplicity","title":"Path Simplicity","text":"<p>BLine paths are simple and relatively quick to create.</p> <p>Consider a straight-line path with no intermediary elements, simply going between two points where the robot is at rest at both. Both Choreo and PathPlanner would essentially create a trapezoidal motion profile, introducing the aforementioned time-parameterized controller pains for a very simple path. This takes more computational resources, adds hassle (control points, anchors, Choreo optimizer), and results in a nearly identically performing path compared to BLine.</p> <p>BLine can also function with only one path element (waypoint), useful for aligning to the Reefscape Reef or Crescendo Amp in teleop or auto. This essentially turns BLine into a bare-bones drive-to-point PID command without the hassle of a separate solution.</p>"},{"location":"concepts/design-philosophy/#control-architecture","title":"Control Architecture","text":""},{"location":"concepts/design-philosophy/#the-three-pid-controllers","title":"The Three PID Controllers","text":"<p>The BLine tracking control loop runs three separate PID controllers that work together:</p> Controller Purpose Input Output Translation Minimizes total remaining path distance Distance to path end (m) Desired velocity (m/s) Rotation Follows profiled rotation or snaps to target Rotation error (rad) Angular velocity (rad/s) Cross-Track Error (CTE) Minimizes deviation from path line Perpendicular distance (m) Correction velocity (m/s) <p>The translation controller drives the robot to the final path element. The rotation controller either follows the profiled rotation or snaps directly to the target if no profile is specified. The CTE controller minimizes deviation from the line between the current and previous path segments, helping reduce post-handoff CTE.</p>"},{"location":"concepts/design-philosophy/#algorithm-robustness","title":"Algorithm Robustness","text":"<p>The BLine path tracking algorithm is robust in its response to sharp changes in positional data.</p> <p>Why it's stable:</p> <ul> <li>Initial computation for translational speed magnitude depends on distance to the path's end</li> <li>Velocity direction depends on the next available waypoint</li> <li>These values are acceleration-limited in 2D to provide smooth robot motion toward the target</li> <li>Chassis output remains relatively stable even during erroneous odometry jitter</li> </ul> <p>Non-time-parameterized advantage:</p> <p>BLine is not time-parameterized like PathPlanner. The control cycle acts in a greedy fashion, which makes the response uniform regardless of path completion or \"lag\" behind the idealized path.</p> <p>Edge Cases</p> <p>Collisions and jitter can be problematic if they are significant enough relative to the handoff radii of the elements\u2014particularly when the target is about to switch at high velocities relative to the max acceleration.</p> <p>Future improvements may include dynamic handoff radii that scale based on cross-track error and segment completion.</p>"},{"location":"concepts/design-philosophy/#intermediary-elements-constraints","title":"Intermediary Elements &amp; Constraints","text":"<p>For paths with intermediary elements, BLine retains its ease of controller tuning and computational simplicity. Just as B\u00e9zier paths have control points and anchors, BLine paths use:</p> <ul> <li>Path elements \u2014 Define where the robot should go</li> <li>Handoff radii \u2014 Control when targets switch</li> <li>Translational velocity limiting \u2014 Primary means of motion control</li> </ul> <p>Ranged constraints ensure the robot doesn't overshoot intermediary elements due to high velocities. To create more complex BLine paths, users manually define these constraints. After creating one or two paths, users quickly build intuition for appropriate constraints. The GUI simulation also aids in understanding robot behavior.</p> <p>Through this system of constraints, handoff radii, and path elements:</p> <ul> <li>The forgivingness and performance of the translational PID controller is maintained</li> <li>Computational simplicity is preserved</li> <li>Users gain fine control over exact robot behavior at individual path elements (velocity and precision)</li> <li>This opens the door for rapid and effective empirical tuning, testing, and validation</li> </ul> <p>BLine provides as much intermediary control as the user wants (within polyline reason) and can create complex autonomous routines.</p>"},{"location":"concepts/design-philosophy/#comparison-to-other-solutions","title":"Comparison to Other Solutions","text":"Feature BLine PathPlanner / Choreo AutoPilot Path type Polyline B\u00e9zier curves Drive-to-point Time-parameterized No Yes No Precomputation required No Yes No Tuning difficulty Low Medium-High Low Intermediary control Full Full Limited Real-time path creation Excellent Limited Excellent Complex paths Yes Yes Limited Single-point moves Yes Overkill Yes <p>Compared to AutoPilot:</p> <p>The ease of tuning should be similar, as AutoPilot also circumvents time-parameterized tracking issues via its own approach. However, AutoPilot performs best in simpler cases and isn't designed for paths requiring intermediary element control (3+ translation elements). BLine handles both simple and complex paths well.</p>"},{"location":"concepts/design-philosophy/#current-limitations","title":"Current Limitations","text":""},{"location":"concepts/design-philosophy/#event-triggers","title":"Event Triggers","text":"<p>Currently, BLine does not support event triggers built into paths. This is a planned feature (likely before kickoff or shortly after).</p> <p>Current workaround: Users can replicate trigger-like functionality via a <code>WaitUntil</code> command checking the path follower's current tracked rotation or translation:</p> <pre><code>// Example: Wait until robot is past a certain point\nCommands.sequence(\n    pathBuilder.build(myPath),\n    // Event triggers would go here - currently use WaitUntil with custom conditions\n);\n</code></pre>"},{"location":"concepts/design-philosophy/#sharp-corner-edge-cases","title":"Sharp Corner Edge Cases","text":"<p>At very high velocities with small handoff radii, corner overshoot can occur. Solutions include:</p> <ul> <li>Using ranged velocity constraints before sharp turns</li> <li>Increasing handoff radii where precision isn't critical</li> <li>Adding intermediate path elements for smoother curves</li> </ul> <p>Best Practice</p> <p>The max translational velocity constraint is the most effective method for counteracting overshoot at sharp turns\u2014more so than increasing handoff radius, which reduces path precision.</p>"},{"location":"concepts/key-parameters/","title":"Key Parameters","text":"<p>Understanding these key parameters is essential for tuning BLine paths for optimal performance.</p>"},{"location":"concepts/key-parameters/#handoff-radius","title":"Handoff Radius","text":"<p>The intermediate handoff radius determines how close the robot must get to a translation target before advancing to the next one. On the canvas, this is visualized as a magenta dashed circle around translation elements.</p> <p></p>"},{"location":"concepts/key-parameters/#how-it-works","title":"How It Works","text":"<p>When the robot enters the handoff radius of the current target, the path follower advances to the next element, creating smooth transitions between segments.</p>"},{"location":"concepts/key-parameters/#tuning-guidelines","title":"Tuning Guidelines","text":"Radius Size Behavior Use Case Smaller Robot waits longer before switching targets Better precision at waypoints, but can cause hesitation Larger Robot switches sooner Smoother transitions at speed, but may cut corners <p>Critical Warning</p> <p>If the radius is too small, the robot may overshoot and miss the handoff zone entirely at high velocities\u2014this causes erratic path behavior and is the worst-case scenario. Conversely, if the handoff radius is too large, the robot will switch targets too early, causing path instability.</p> <p>Smooth Turns: Add More Elements</p> <p>For smoother, more accurate navigation through turns, try adding a few extra TranslationTargets or Waypoints along the curve. This approach lets the robot follow the desired path more naturally\u2014without needing aggressive velocity constraints or oversize handoff radii. More elements create a gentler, better-controlled trajectory through each bend.  Just be sure not to oversaturate your paths and keep them as sparse as possible.</p>"},{"location":"concepts/key-parameters/#setting-handoff-radius","title":"Setting Handoff Radius","text":"<p>Per-element in the GUI sidebar, or via the <code>intermediate_handoff_radius_meters</code> field in JSON.</p> <p>Project-wide default in Settings \u2192 Robot Config (GUI) or via <code>config.json</code>:</p> <pre><code>{\n    \"default_intermediate_handoff_radius_meters\": 0.2\n}\n</code></pre>"},{"location":"concepts/key-parameters/#t_ratio-rotation-targets","title":"t_ratio (Rotation Targets)","text":"<p>The t_ratio parameter defines where along the path segment (0.0 to 1.0) a rotation should be achieved. This only applies to <code>RotationTarget</code> elements.</p>"},{"location":"concepts/key-parameters/#values","title":"Values","text":"t_ratio Position Along Segment <code>0.0</code> Rotation at the start of the segment <code>0.5</code> Rotation at the midpoint <code>1.0</code> Rotation at the end of the segment"},{"location":"concepts/key-parameters/#how-its-used","title":"How It's Used","text":"<p>The path follower calculates the robot's progress along the current segment as a ratio (0.0 to 1.0). Rotation targets are processed when the robot's progress exceeds the target's t_ratio.</p> <p>For profiled rotation, the rotation setpoint interpolates smoothly based on progress. For non-profiled rotation, the robot immediately adopts the target rotation upon reaching the t_ratio threshold.</p>"},{"location":"concepts/key-parameters/#gui-interaction","title":"GUI Interaction","text":"<p>In the GUI, simply drag the RotationTarget along its connecting line to adjust the t_ratio visually. The element snaps to positions along the segment.</p> <p></p>"},{"location":"concepts/key-parameters/#profiled-rotation","title":"Profiled Rotation","text":"<p>The profiled rotation setting controls how the robot transitions to a target rotation.</p>"},{"location":"concepts/key-parameters/#profiled-default-true","title":"Profiled (Default: <code>true</code>)","text":"<p>The robot smoothly interpolates its rotation based on t-ratio progression along the path:</p> <ul> <li>As the robot travels, its rotation setpoint gradually transitions toward the target rotation</li> <li>The transition is proportional to segment progress</li> <li>Results in smooth, predictable rotation behavior</li> </ul> <pre><code>{\n    \"type\": \"rotation\",\n    \"rotation_radians\": 1.57,\n    \"t_ratio\": 0.5,\n    \"profiled_rotation\": true\n}\n</code></pre>"},{"location":"concepts/key-parameters/#non-profiled-false","title":"Non-Profiled (<code>false</code>)","text":"<p>The robot immediately snaps to the target rotation when it enters the segment:</p> <ul> <li>No interpolation based on position</li> <li>Useful when you want an immediate rotation change</li> <li>Can be more aggressive but less smooth</li> </ul> <pre><code>{\n    \"type\": \"rotation\",\n    \"rotation_radians\": 1.57,\n    \"t_ratio\": 0.5,\n    \"profiled_rotation\": false\n}\n</code></pre>"},{"location":"concepts/key-parameters/#when-to-use-each","title":"When to Use Each","text":"Mode Best For Profiled Most situations; smooth autonomous routines Non-Profiled Quick reaction rotations; when you need immediate rotation change <p>Toggle this setting per-element in the sidebar under \"Profiled Rotation\".</p>"},{"location":"concepts/key-parameters/#end-tolerances","title":"End Tolerances","text":"<p>End tolerances determine when the path follower considers the path complete.</p>"},{"location":"concepts/key-parameters/#end-translation-tolerance","title":"End Translation Tolerance","text":"<p>How close (in meters) the robot must be to the final position to finish the path.</p> <ul> <li>Smaller values \u2192 More precise final positioning, but may take longer or oscillate</li> <li>Larger values \u2192 Faster completion, but less precise</li> </ul> <p>Typical values: <code>0.02</code> to <code>0.1</code> meters</p>"},{"location":"concepts/key-parameters/#end-rotation-tolerance","title":"End Rotation Tolerance","text":"<p>How close (in degrees) the robot must be to the final rotation to finish the path.</p> <ul> <li>Smaller values \u2192 More precise final rotation</li> <li>Larger values \u2192 Faster completion</li> </ul> <p>Typical values: <code>1.0</code> to <code>5.0</code> degrees</p>"},{"location":"concepts/key-parameters/#setting-tolerances","title":"Setting Tolerances","text":"<p>In code:</p> <pre><code>Path.PathConstraints constraints = new Path.PathConstraints()\n    .setEndTranslationToleranceMeters(0.02)  // 2 cm\n    .setEndRotationToleranceDeg(1.0);        // 1 degree\n</code></pre> <p>In JSON:</p> <pre><code>{\n    \"constraints\": {\n        \"end_translation_tolerance_meters\": 0.03,\n        \"end_rotation_tolerance_deg\": 2.0\n    }\n}\n</code></pre>"},{"location":"concepts/key-parameters/#parameter-interaction","title":"Parameter Interaction","text":"<p>These parameters work together during path execution:</p> Step Action Key Parameter 1 Robot drives toward current translation target Translation controller 2 Speed capped by active constraints Max velocity 3 Target switches when robot enters handoff zone Handoff radius 4 Heading adjusts toward next rotation target T-ratio, profiled rotation 5 Final target checks position and heading End tolerances 6 Path completes when both tolerances satisfied End translation/rotation tolerance <p>Balancing Parameters</p> <ul> <li>Higher velocity requires larger handoff radius to prevent overshoot</li> <li>Tighter turns benefit from lower velocity constraints on those segments</li> <li>Precision maneuvers need smaller tolerances, smaller handoff radii, and lower velocities</li> </ul>"},{"location":"concepts/path-elements/","title":"Path Elements","text":"<p>BLine represents autonomous paths as sequences of path elements. Understanding these elements is essential for effective path planning, whether you're using the GUI or defining paths in code.</p>"},{"location":"concepts/path-elements/#element-types","title":"Element Types","text":"<p>A Path is a sequence of path elements that define where the robot should go and what holonomic rotation it should have:</p> Element Description Waypoint A point with both a position (translation) and holonomic rotation target TranslationTarget A position-only target\u2014the robot drives through this point RotationTarget A rotation-only target that interpolates based on progress along a segment"},{"location":"concepts/path-elements/#visual-representation-in-gui","title":"Visual Representation in GUI","text":"Element Canvas Appearance Waypoint Orange rectangle with rotation handle TranslationTarget Blue circle RotationTarget Green dashed rectangle with rotation handle"},{"location":"concepts/path-elements/#waypoints","title":"Waypoints","text":"<p>A Waypoint combines both translation and rotation\u2014the robot drives to this position AND rotates to the specified rotation.</p>"},{"location":"concepts/path-elements/#when-to-use-waypoints","title":"When to Use Waypoints","text":"<p>Use Waypoints when the robot needs to face a specific direction at a location:</p> <ul> <li>Scoring positions (need to face the target)</li> <li>Intake stations (need to face the game piece source)</li> <li>Any position where rotation matters</li> </ul>"},{"location":"concepts/path-elements/#code-example","title":"Code Example","text":"<pre><code>// Create a waypoint at (1.0, 1.0) facing 0 degrees\nnew Path.Waypoint(new Translation2d(1.0, 1.0), new Rotation2d(0))\n\n// Or from a Pose2d\nnew Path.Waypoint(new Pose2d(1.0, 1.0, new Rotation2d(0)))\n</code></pre>"},{"location":"concepts/path-elements/#json-example","title":"JSON Example","text":"<pre><code>{\n    \"type\": \"waypoint\",\n    \"translation_target\": {\n        \"x_meters\": 1.0,\n        \"y_meters\": 1.0,\n        \"intermediate_handoff_radius_meters\": 0.2\n    },\n    \"rotation_target\": {\n        \"rotation_radians\": 0,\n        \"profiled_rotation\": true\n    }\n}\n</code></pre>"},{"location":"concepts/path-elements/#translation-targets","title":"Translation Targets","text":"<p>A TranslationTarget is a position-only target\u2014the robot drives through this point without changing its rotation setpoint.</p>"},{"location":"concepts/path-elements/#when-to-use-translation-targets","title":"When to Use Translation Targets","text":"<p>Use TranslationTargets for intermediate points where rotation doesn't matter:</p> <ul> <li>Avoiding obstacles</li> <li>Path shaping (creating curves)</li> <li>Points along a route where you don't care about rotation</li> </ul>"},{"location":"concepts/path-elements/#code-example_1","title":"Code Example","text":"<pre><code>// Create a translation target at (2.0, 2.0)\nnew Path.TranslationTarget(new Translation2d(2.0, 2.0))\n\n// Or directly from coordinates\nnew Path.TranslationTarget(2.0, 2.0)\n</code></pre>"},{"location":"concepts/path-elements/#json-example_1","title":"JSON Example","text":"<pre><code>{\n    \"type\": \"translation\",\n    \"x_meters\": 2.5,\n    \"y_meters\": 2.0,\n    \"intermediate_handoff_radius_meters\": 0.2\n}\n</code></pre>"},{"location":"concepts/path-elements/#rotation-targets","title":"Rotation Targets","text":"<p>A RotationTarget is a rotation-only target positioned along a segment between anchors. The robot turns to this holonomic rotation while traveling between translation points.</p>"},{"location":"concepts/path-elements/#when-to-use-rotation-targets","title":"When to Use Rotation Targets","text":"<p>Use RotationTargets when you need the robot to rotate mid-segment without adding a translation point:</p> <ul> <li>Preparing rotation for the next action</li> <li>Smooth rotation transitions</li> <li>Rotation control were translation does not matter</li> </ul>"},{"location":"concepts/path-elements/#the-t_ratio-parameter","title":"The t_ratio Parameter","text":"<p>RotationTargets exist between anchors (Waypoints or TranslationTargets). The t_ratio parameter (0.0\u20131.0) determines where along the segment the rotation occurs:</p> t_ratio Position <code>0.0</code> Rotation at the start of the segment <code>0.5</code> Rotation at the midpoint <code>1.0</code> Rotation at the end of the segment <p>In the GUI, simply drag the RotationTarget along its connecting line to adjust the t_ratio visually.</p> <p></p>"},{"location":"concepts/path-elements/#code-example_2","title":"Code Example","text":"<pre><code>// Rotate to 90 degrees at the midpoint of the segment\nnew Path.RotationTarget(new Rotation2d(Math.PI / 2), 0.5)\n</code></pre>"},{"location":"concepts/path-elements/#json-example_2","title":"JSON Example","text":"<pre><code>{\n    \"type\": \"rotation\",\n    \"rotation_radians\": 1.57,\n    \"t_ratio\": 0.5,\n    \"profiled_rotation\": true\n}\n</code></pre>"},{"location":"concepts/path-elements/#profiled-vs-non-profiled-rotation","title":"Profiled vs Non-Profiled Rotation","text":"<p>Both Waypoints and RotationTargets support a profiled rotation setting that controls how the robot transitions to the target rotation:</p>"},{"location":"concepts/path-elements/#profiled-rotation-default","title":"Profiled Rotation (Default)","text":"<p>The robot smoothly interpolates its rotation based on its t-ratio progression along the path. As the robot travels between anchors, its rotation setpoint gradually transitions toward the target rotation proportional to how far it has traveled along the segment.</p>"},{"location":"concepts/path-elements/#non-profiled-rotation","title":"Non-Profiled Rotation","text":"<p>The robot immediately snaps to the target rotation when it enters the segment\u2014no interpolation based on position. This is useful when you want an immediate rotation change.</p> <p>Toggle this setting per-element in the GUI sidebar under \"Profiled Rotation\", or set <code>profiled_rotation</code> in JSON/code.</p>"},{"location":"concepts/path-elements/#building-complete-paths","title":"Building Complete Paths","text":"<p>A path is simply a sequence of these elements. Here's an example combining all three types:</p> <pre><code>Path myPath = new Path(\n    // Start at (1,1) facing 0 degrees\n    new Path.Waypoint(new Translation2d(1.0, 1.0), new Rotation2d(0)),\n\n    // Drive through (2,2) - rotation unchanged\n    new Path.TranslationTarget(new Translation2d(2.0, 2.0)),\n\n    // Rotate to 90 degrees at midpoint of next segment\n    new Path.RotationTarget(new Rotation2d(Math.PI / 2), 0.5),\n\n    // End at (3,1) facing 180 degrees\n    new Path.Waypoint(new Translation2d(3.0, 1.0), new Rotation2d(Math.PI))\n);\n</code></pre> <p>Single-Element Paths</p> <p>Paths can consist of just one Waypoint or TranslationTarget\u2014useful for simple point-to-point moves. Note that a path with only a RotationTarget is invalid (you need at least one translation element).</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>BLine consists of two components: the GUI for visual path planning, and the Library for path following on your robot. Install whichever components fit your workflow.</p>"},{"location":"getting-started/installation/#bline-gui-installation","title":"BLine-GUI Installation","text":""},{"location":"getting-started/installation/#prebuilt-binaries-recommended","title":"Prebuilt Binaries (Recommended)","text":"<p>Download the latest release for your platform from the Releases page.</p> WindowsLinuxmacOS <p>Installer (Recommended)</p> <ol> <li>Download <code>BLine-{version}-Setup.exe</code></li> <li>Run the installer and follow the wizard</li> <li>Launch BLine from the Start Menu</li> </ol> <p>Portable (No Installation)</p> <ol> <li>Download <code>BLine-{version}-Windows-Portable.zip</code></li> <li>Extract anywhere</li> <li>Run <code>BLine.exe</code></li> </ol> <p>No Python installation required\u2014everything is bundled!</p> <p>AppImage (All Distributions)</p> <ol> <li>Download <code>BLine-x86_64.AppImage</code></li> <li>Make it executable:    <pre><code>chmod +x BLine-x86_64.AppImage\n</code></pre></li> <li>Run it:    <pre><code>./BLine-x86_64.AppImage\n</code></pre></li> </ol> <p>No installation or dependencies required!</p> <p>macOS builds are not currently available as prebuilt binaries. See Install from Source below.</p>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>If you prefer to install via Python package or need the latest development version:</p> <p>Quick Install (all platforms):</p> <pre><code>pipx install git+https://github.com/edanliahovetsky/BLine-GUI.git\n</code></pre> <p>Then run <code>bline</code> from anywhere.</p> Don't have pipx? Platform-specific instructions WindowsmacOSLinux <pre><code># Install pipx (one-time setup)\npip install pipx\npipx ensurepath\n\n# Restart your terminal, then install BLine\npipx install git+https://github.com/edanliahovetsky/BLine-GUI.git\n</code></pre> <p>Troubleshooting: If you get a PySide6 build error, install Python 3.11 or 3.12 from python.org and specify it:</p> <pre><code>py -3.12 -m pip install --upgrade pip pipx\npy -3.12 -m pipx ensurepath\npy -3.12 -m pipx install git+https://github.com/edanliahovetsky/BLine-GUI.git\n</code></pre> <pre><code># Install Homebrew if needed\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install pipx and BLine\nbrew install pipx\npipx ensurepath\npipx install git+https://github.com/edanliahovetsky/BLine-GUI.git\n</code></pre> <pre><code># Install pipx\n# Debian/Ubuntu:\nsudo apt install pipx\n\n# Fedora:\nsudo dnf install pipx\n\n# Arch:\nsudo pacman -S python-pipx\n\n# Install BLine\npipx ensurepath\npipx install git+https://github.com/edanliahovetsky/BLine-GUI.git\n</code></pre> <p>Troubleshooting: If you get a PySide6 build error, specify Python 3.11 or 3.12:</p> <pre><code>pipx install --python python3.12 git+https://github.com/edanliahovetsky/BLine-GUI.git\n</code></pre>"},{"location":"getting-started/installation/#updating-the-gui","title":"Updating the GUI","text":"<pre><code># If you used pipx:\npipx upgrade bline\n\n# If you used pip (with venv activated):\npip install --upgrade git+https://github.com/edanliahovetsky/BLine-GUI.git\n</code></pre> If <code>pipx upgrade bline</code> fails on Windows <p>This can happen if pipx is pointing at a moved/updated Python install. Try:</p> <pre><code># Recreate the pipx venv for bline\npipx reinstall bline\n\n# Or remove + install fresh\npipx uninstall bline\npipx install git+https://github.com/edanliahovetsky/BLine-GUI.git\n</code></pre>"},{"location":"getting-started/installation/#uninstalling-the-gui","title":"Uninstalling the GUI","text":"<pre><code># If you used pipx:\npipx uninstall bline\n\n# If you used pip:\n# Just delete the BLine folder you created\n</code></pre>"},{"location":"getting-started/installation/#bline-lib-installation","title":"BLine-Lib Installation","text":""},{"location":"getting-started/installation/#using-vendor-json-recommended","title":"Using Vendor JSON (Recommended)","text":"<ol> <li>Open VS Code with your FRC project</li> <li>Press <code>Ctrl+Shift+P</code> (or <code>Cmd+Shift+P</code> on Mac)</li> <li>Type \"WPILib: Manage Vendor Libraries\"</li> <li>Select \"Install new libraries (online)\"</li> <li>Paste this URL:</li> </ol> <pre><code>https://raw.githubusercontent.com/edanliahovetsky/BLine-Lib/main/BLine-Lib.json\n</code></pre>"},{"location":"getting-started/installation/#using-gradle-alternative","title":"Using Gradle (Alternative)","text":"<p>Add JitPack repository to your <code>build.gradle</code>:</p> <pre><code>repositories {\n    maven { url 'https://jitpack.io' }\n}\n</code></pre> <p>Add the dependency:</p> <pre><code>dependencies {\n    implementation 'com.github.edanliahovetsky:BLine-Lib:0.4.0'\n}\n</code></pre>"},{"location":"getting-started/installation/#recommended-usage-modes","title":"Recommended Usage Modes","text":"<p>There are three recommended ways to use BLine, depending on your team's workflow:</p> Mode Description Components Needed Full Stack Visual path planning with JSON export GUI + Lib JSON Primary Define paths directly in JSON files Lib only Code Only Define all paths programmatically in Java Lib only <p>Choose the approach that best fits your team's preferences and workflow!</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide walks you through creating and following your first BLine path.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>BLine-Lib installed in your FRC project</li> <li>A holonomic drivetrain (swerve, mecanum, etc.)</li> <li>Basic familiarity with WPILib command-based programming</li> </ul>"},{"location":"getting-started/quick-start/#step-1-set-global-constraints","title":"Step 1: Set Global Constraints","text":"<p>Global constraints define default velocity/acceleration limits and tolerances for all paths. Choose one approach:</p> Using config.jsonIn Code <p>Create a <code>config.json</code> file in <code>src/main/deploy/autos/</code>:</p> <pre><code>{\n    \"default_max_velocity_meters_per_sec\": 4.5,\n    \"default_max_acceleration_meters_per_sec2\": 12.0,\n    \"default_max_velocity_deg_per_sec\": 540,\n    \"default_max_acceleration_deg_per_sec2\": 860,\n    \"default_end_translation_tolerance_meters\": 0.03,\n    \"default_end_rotation_tolerance_deg\": 2.0,\n    \"default_intermediate_handoff_radius_meters\": 0.2\n}\n</code></pre> <p>Set global constraints programmatically in your robot initialization:</p> <pre><code>// Set global constraints before creating any paths\nPath.setDefaultGlobalConstraints(new Path.DefaultGlobalConstraints(\n    4.5,    // maxVelocityMetersPerSec\n    12.0,   // maxAccelerationMetersPerSec2\n    540,    // maxVelocityDegPerSec\n    860,    // maxAccelerationDegPerSec2\n    0.03,   // endTranslationToleranceMeters\n    2.0,    // endRotationToleranceDeg\n    0.2     // intermediateHandoffRadiusMeters\n));\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-create-a-followpath-builder","title":"Step 2: Create a FollowPath Builder","text":"<p>Create a reusable <code>FollowPath.Builder</code> in your drive subsystem or <code>RobotContainer</code>:</p> <pre><code>import frc.robot.lib.BLine.*;\nimport edu.wpi.first.math.controller.PIDController;\n\n// Create a reusable builder with your robot's configuration\nFollowPath.Builder pathBuilder = new FollowPath.Builder(\n    driveSubsystem,                      // The drive subsystem to require\n    driveSubsystem::getPose,             // Supplier for current robot pose\n    driveSubsystem::getChassisSpeeds,    // Supplier for current speeds\n    driveSubsystem::drive,               // Consumer to drive the robot\n    new PIDController(5.0, 0.0, 0.0),    // Translation PID\n    new PIDController(3.0, 0.0, 0.0),    // Rotation PID\n    new PIDController(2.0, 0.0, 0.0)     // Cross-track PID\n).withDefaultShouldFlip()                // Auto-flip for red alliance\n .withPoseReset(driveSubsystem::resetPose);  // Reset odometry at path start\n</code></pre> <p>PID Controllers</p> <ul> <li>Translation Controller: Controls speed based on distance remaining to path end</li> <li>Rotation Controller: Controls holonomic rotation toward rotation targets</li> <li>Cross-Track Controller: Minimizes deviation from the path line</li> </ul>"},{"location":"getting-started/quick-start/#step-3-create-and-follow-paths","title":"Step 3: Create and Follow Paths","text":"From JSON FileProgrammatically <p>Place your path JSON in <code>deploy/autos/paths/</code>, then load it:</p> <pre><code>// Loads deploy/autos/paths/myPathFile.json\n// Note: .json extension is added automatically\nPath myPath = new Path(\"myPathFile\");\n\nCommand followCommand = pathBuilder.build(myPath);\n</code></pre> <p>Create paths directly in code:</p> <pre><code>Path myPath = new Path(\n    new Path.Waypoint(new Translation2d(1.0, 1.0), new Rotation2d(0)),\n    new Path.TranslationTarget(new Translation2d(2.0, 2.0)),\n    new Path.Waypoint(new Translation2d(3.0, 1.0), new Rotation2d(Math.PI))\n);\n\nCommand followCommand = pathBuilder.build(myPath);\n</code></pre>"},{"location":"getting-started/quick-start/#step-4-use-in-autonomous","title":"Step 4: Use in Autonomous","text":"<p>Add the follow command to your autonomous routine:</p> <pre><code>public Command getAutonomousCommand() {\n    Path scorePath = new Path(\"scoreFirst\");\n    Path pickupPath = new Path(\"intake\");\n\n    return Commands.sequence(\n        pathBuilder.build(scorePath),\n        // Add scoring action here\n        pathBuilder.build(pickupPath)\n        // Continue with more actions...\n    );\n}\n</code></pre>"},{"location":"getting-started/quick-start/#step-5-pre-orient-modules-recommended","title":"Step 5: Pre-Orient Modules (Recommended)","text":"<p>For optimal autonomous performance, pre-orient your swerve modules toward the initial path direction before the match begins. This prevents micro-deviations at the start caused by modules needing to rotate during driving.</p> <pre><code>// In your autonomous initialization or pre-match routine\nPath autoPath = new Path(\"myAutoPath\");\nRotation2d initialDirection = autoPath.getInitialModuleDirection();\n\ndriveSubsystem.setModuleOrientations(initialDirection);\n</code></pre>"},{"location":"getting-started/quick-start/#adding-path-specific-constraints-optional","title":"Adding Path-Specific Constraints (Optional)","text":"<p>Override global constraints for individual paths:</p> <pre><code>Path.PathConstraints slowConstraints = new Path.PathConstraints()\n    .setMaxVelocityMetersPerSec(2.0)\n    .setMaxAccelerationMetersPerSec2(11)\n    .setMaxVelocityDegPerSec(180.0)\n    .setMaxAccelerationDegPerSec2(360.0)\n    .setEndTranslationToleranceMeters(0.02)\n    .setEndRotationToleranceDeg(1.0);\n\n// Create path with custom constraints\nPath slowPath = new Path(\n    slowConstraints,\n    new Path.Waypoint(new Translation2d(1.0, 1.0), new Rotation2d(0)),\n    new Path.TranslationTarget(new Translation2d(2.0, 2.0)),\n    new Path.Waypoint(new Translation2d(3.0, 1.0), new Rotation2d(Math.PI))\n);\n</code></pre> <p>You can also use ranged constraints to vary limits across different path segments:</p> <pre><code>Path.PathConstraints rangedConstraints = new Path.PathConstraints()\n    .setMaxVelocityMetersPerSec(\n        new Path.RangedConstraint(4.0, 0, 2),  // Fast for elements 0-2\n        new Path.RangedConstraint(1.5, 3, 5)   // Slow for elements 3-5\n    );\n</code></pre> <p>See Constraints for more details on the constraint system.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts \u2014 Understand path elements in depth</li> <li>GUI Overview \u2014 Learn to use the visual path editor</li> <li>Path Construction \u2014 Detailed path creation guide</li> <li>Usage Tips \u2014 Best practices for tuning and optimization</li> </ul>"},{"location":"gui/","title":"GUI Overview","text":"<p>BLine-GUI is a visual path planning interface for designing and editing autonomous paths. It provides real-time simulation preview and exports paths as JSON files that BLine-Lib can load.</p> <p></p>"},{"location":"gui/#getting-started","title":"Getting Started","text":"<p>Binary installation: Launch BLine from your Start Menu (Windows), Applications folder, or run the executable directly.</p> <p>Python package installation: Run <code>bline</code> from any terminal. To create a desktop shortcut with the BLine icon, run <code>bline --create-shortcut</code>.</p>"},{"location":"gui/#interface-layout","title":"Interface Layout","text":"<p>The BLine GUI consists of three main areas:</p> Area Purpose Menu Bar Project management, path operations, editing tools, and settings Canvas Visual field display with interactive path editing Sidebar Element list, properties panel, and constraint editor Transport Controls Simulation playback controls"},{"location":"gui/#key-features","title":"Key Features","text":""},{"location":"gui/#visual-path-editing","title":"Visual Path Editing","text":"<ul> <li>Drag elements to reposition on the field</li> <li>Rotate rotations with visual handles</li> <li>Add, remove, and reorder elements</li> <li>Real-time path visualization</li> </ul>"},{"location":"gui/#constraint-management","title":"Constraint Management","text":"<ul> <li>Set global constraints in Robot Config</li> <li>Add ranged constraints with visual feedback</li> <li>See constraint coverage on the path</li> </ul>"},{"location":"gui/#simulation-preview","title":"Simulation Preview","text":"<ul> <li>Play/pause path simulation</li> <li>Scrub through timeline</li> <li>View robot trajectory</li> <li>Estimate path duration</li> </ul>"},{"location":"gui/#element-colors","title":"Element Colors","text":"<p>On the canvas, elements are color-coded:</p> Color Element Type \ud83d\udfe0 Orange Waypoint (position + rotation) \ud83d\udd35 Blue TranslationTarget (position only) \ud83d\udfe2 Green dashed RotationTarget (rotation only) \ud83d\udfe3 Magenta dashed circle Handoff radius"},{"location":"gui/#workflow","title":"Workflow","text":"<p>A typical path creation workflow:</p> <ol> <li>Create a new project or open an existing one</li> <li>Configure Robot Settings (Settings \u2192 Robot Config)</li> <li>Add path elements by clicking on the canvas or using the sidebar</li> <li>Position elements by dragging them on the field</li> <li>Set rotations using the rotation handles</li> <li>Add constraints for velocity limits on specific segments</li> <li>Preview using the simulation controls</li> <li>Save the path (automatically exports JSON)</li> </ol>"},{"location":"gui/#project-structure","title":"Project Structure","text":"<p>BLine organizes projects in a <code>deploy/autos/</code> directory:</p> <pre><code>autos/\n\u251c\u2500\u2500 config.json          # Global constraints and robot config\n\u2514\u2500\u2500 paths/\n    \u251c\u2500\u2500 score_first.json\n    \u251c\u2500\u2500 intake.json\n    \u2514\u2500\u2500 ...\n</code></pre> <p>The <code>paths/</code> folder corresponds to <code>deploy/autos/paths/</code> in your robot code.</p> <p>Keyboard Shortcuts</p> <ul> <li><code>Space</code> - Play/pause simulation (when canvas is focused)</li> <li><code>Delete</code> / <code>Backspace</code> - Remove selected elements</li> <li><code>Ctrl+Z</code> - Undo</li> <li><code>Ctrl+Y</code> - Redo</li> </ul>"},{"location":"gui/#learn-more","title":"Learn More","text":"<ul> <li>Menu Bar \u2014 Project management, path operations, and settings</li> <li>Canvas \u2014 Detailed canvas interactions and controls</li> <li>Sidebar \u2014 Element editing and constraint management</li> <li>Simulation \u2014 Using the simulation preview</li> </ul>"},{"location":"gui/canvas/","title":"Canvas","text":"<p>The canvas is the main visual workspace where you design your paths. It displays the FRC field with your path overlaid, allowing direct manipulation of path elements.</p>"},{"location":"gui/canvas/#navigation","title":"Navigation","text":""},{"location":"gui/canvas/#zooming","title":"Zooming","text":"<p>Use the scroll wheel to zoom in and out of the canvas.</p> <p></p>"},{"location":"gui/canvas/#panning","title":"Panning","text":"<p>Click and drag on empty space (not on an element) to pan the view around the field.</p> <p></p>"},{"location":"gui/canvas/#selecting-elements","title":"Selecting Elements","text":"<p>Click on any element to select it. The selected element will be highlighted, and its properties will appear in the sidebar.</p>"},{"location":"gui/canvas/#moving-elements","title":"Moving Elements","text":"<p>Drag translation elements (Waypoints and TranslationTargets) to reposition them on the field.</p> <p></p> <p>Tip</p> <p>The element's coordinates update in real-time in the sidebar as you drag.</p>"},{"location":"gui/canvas/#adjusting-rotation","title":"Adjusting Rotation","text":"<p>Waypoints and RotationTargets have rotation handles\u2014small circles extending from the element that indicate the rotation direction.</p> <p>Drag the rotation handle to adjust the element's rotation.</p> <p></p>"},{"location":"gui/canvas/#moving-rotation-targets","title":"Moving Rotation Targets","text":"<p>RotationTargets exist along the path segment between two anchor points. Drag a RotationTarget along its connecting line to adjust its t_ratio (position along the segment).</p> <p></p>"},{"location":"gui/canvas/#deleting-elements","title":"Deleting Elements","text":"<p>Select an element and press Delete or Backspace to remove it from the path.</p> <p>Alternatively, use the \u2715 button in the sidebar's element list.</p>"},{"location":"gui/canvas/#element-visualization","title":"Element Visualization","text":""},{"location":"gui/canvas/#color-coding","title":"Color Coding","text":"Element Appearance Waypoint Orange rectangle with rotation handle line TranslationTarget Blue circle RotationTarget Green dashed rectangle with rotation handle line"},{"location":"gui/canvas/#path-lines","title":"Path Lines","text":"<p>Lines connect translation elements (Waypoints and TranslationTargets) showing the path the robot will follow. RotationTargets appear as markers along these lines.</p>"},{"location":"gui/canvas/#handoff-radius","title":"Handoff Radius","text":"<p>Each translation element displays a magenta dashed circle representing its handoff radius. The robot advances to the next target when it enters this circle.</p> <p></p>"},{"location":"gui/canvas/#constraint-visualization","title":"Constraint Visualization","text":"<p>When you click on a ranged constraint's slider in the sidebar, a green overlay highlights the affected path segments on the canvas. This helps you visualize exactly which parts of the path the constraint applies to.</p> <p></p>"},{"location":"gui/canvas/#simulation-view","title":"Simulation View","text":"<p>During simulation playback, the canvas shows:</p> <ul> <li>Robot position moving along the path</li> <li>Orange trail showing the simulated trajectory</li> <li>Current rotation indicated by the robot icon orientation</li> </ul> <p>See Simulation for more details on the simulation features.</p>"},{"location":"gui/canvas/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Shortcut Action <code>Delete</code> / <code>Backspace</code> Delete selected element <code>Space</code> Play/pause simulation <code>Ctrl+Z</code> / <code>Cmd+Z</code> Undo <code>Ctrl+Y</code> / <code>Cmd+Shift+Z</code> Redo <code>Ctrl+S</code> / <code>Cmd+S</code> Save"},{"location":"gui/menu-bar/","title":"Menu Bar","text":"<p>The menu bar provides access to all major application functions for project management, path editing, and configuration.</p> Project MenuPath MenuEdit MenuSettings Menu Action Shortcut Description Open Project\u2026 - Select and open a BLine project directory containing <code>paths/</code> and <code>config.json</code> Recent Projects - Quick access to recently opened project directories Action Shortcut Description Current: [Path Name] - Shows the currently loaded path file (read-only display) Load Path - Submenu showing all available <code>.json</code> path files in the project Create New Path - Start a fresh path with no elements Save Path As\u2026 - Save the current path to a new <code>.json</code> file in the project Rename Path\u2026 - Rename the current path file Delete Paths\u2026 - Select and delete one or more path files from the project Action Shortcut Description Undo <code>Ctrl+Z</code> Undo the last action Redo <code>Ctrl+Y</code> / <code>Ctrl+Shift+Z</code> Redo the previously undone action Action Shortcut Description Edit Config\u2026 - Open the robot configuration editor Setting Description Default Max Velocity Global velocity limit (m/s) Default Max Acceleration Global acceleration limit (m/s\u00b2) Default Max Rotational Velocity Global angular velocity limit (deg/s) Default Max Rotational Acceleration Global angular acceleration limit (deg/s\u00b2) Default Handoff Radius Default radius for new elements (m) End Translation Tolerance Path completion position tolerance (m) End Rotation Tolerance Path completion rotation tolerance (deg) <p>These settings are saved to <code>config.json</code> in your project and used by BLine-Lib when loading paths.</p> <p>Robot Config Workflow</p> <p>Always configure your robot settings before creating paths.</p> <p>Robot configuration changes are saved directly to <code>config.json</code> in your project's <code>/deploy/autos</code> directory. Make sure your robot parameters are correct before designing any paths.</p>"},{"location":"gui/sidebar/","title":"Sidebar","text":"<p>The sidebar provides detailed editing controls for path elements and constraints. It's divided into several panels for different functions.</p>"},{"location":"gui/sidebar/#path-elements-panel","title":"Path Elements Panel","text":"<p>The top section lists all elements in your path in order.</p> <p></p>"},{"location":"gui/sidebar/#element-list","title":"Element List","text":"<p>Each element shows:</p> <ul> <li>Type icon (colored indicator matching canvas colors)</li> <li>Element type (Waypoint, Translation, Rotation)</li> <li>Key properties (coordinates or rotation value)</li> <li>\u2715 button to delete the element</li> </ul>"},{"location":"gui/sidebar/#adding-elements","title":"Adding Elements","text":"<p>Click the \"Add element\" button to insert a new element after the currently selected one.</p> <p></p> <p>If no element is selected, the new element is added at the end of the path.</p>"},{"location":"gui/sidebar/#reordering-elements","title":"Reordering Elements","text":"<p>Drag elements in the list to reorder them. The path will update immediately on the canvas.</p> <p></p> <p>Note</p> <p>Remember that RotationTargets are positioned relative to the segment they're on. Reordering may change which segment a RotationTarget belongs to.</p>"},{"location":"gui/sidebar/#removing-elements","title":"Removing Elements","text":"<p>Click the \u2715 button next to any element to remove it, or select it and press Delete/Backspace.</p>"},{"location":"gui/sidebar/#element-properties-panel","title":"Element Properties Panel","text":"<p>When an element is selected, its properties appear in this panel.</p>"},{"location":"gui/sidebar/#common-properties","title":"Common Properties","text":"Property Applies To Description Type All Dropdown to convert between element types Rotation (deg) Waypoint, RotationTarget rotation in degrees Profiled Rotation Waypoint, RotationTarget Checkbox for rotation interpolation mode"},{"location":"gui/sidebar/#translation-properties","title":"Translation Properties","text":"<p>For Waypoints and TranslationTargets:</p> Property Description X (m) X coordinate in meters Y (m) Y coordinate in meters Handoff Radius (m) Distance at which path advances to next element <p></p>"},{"location":"gui/sidebar/#rotationtarget-properties","title":"RotationTarget Properties","text":"<p>For RotationTargets specifically:</p> Property Description t_ratio Position along segment (0.0 to 1.0) <p>Tip</p> <p>You can also adjust t_ratio by dragging the RotationTarget along its segment on the canvas.</p>"},{"location":"gui/sidebar/#converting-element-types","title":"Converting Element Types","text":"<p>Use the Type dropdown to convert an element to a different type:</p> <ul> <li>Waypoint \u2194 TranslationTarget: Removes or adds rotation data</li> <li>Waypoint \u2194 RotationTarget: Removes or adds translation data</li> <li>TranslationTarget \u2194 RotationTarget: Swaps translation for rotation</li> </ul> <p></p>"},{"location":"gui/sidebar/#path-constraints-panel","title":"Path Constraints Panel","text":"<p>Manage velocity and acceleration constraints for your path.</p>"},{"location":"gui/sidebar/#adding-constraints","title":"Adding Constraints","text":"<p>Click \"Add constraint\" to create a new ranged constraint.</p> <p></p>"},{"location":"gui/sidebar/#constraint-types","title":"Constraint Types","text":"<p>Available constraint types:</p> <ul> <li>Max Velocity (m/s)</li> <li>Max Acceleration (m/s\u00b2)</li> <li>Max Rotational Velocity (deg/s)</li> <li>Max Rotational Acceleration (deg/s\u00b2)</li> </ul>"},{"location":"gui/sidebar/#constraint-properties","title":"Constraint Properties","text":"<p>Each constraint shows:</p> Property Description Type Dropdown to select constraint type Value The limit value Range slider Start and end ordinals (1-based) \u2715 button Remove the constraint"},{"location":"gui/sidebar/#range-slider","title":"Range Slider","text":"<p>The range slider lets you specify which elements the constraint applies to:</p> <ul> <li>Left handle: Start ordinal (first affected element)</li> <li>Right handle: End ordinal (last affected element)</li> </ul> <p></p> <p>Visual Feedback</p> <p>Click on the slider to see a green overlay on the canvas highlighting the affected path segments.</p>"},{"location":"gui/sidebar/#removing-constraints","title":"Removing Constraints","text":"<p>Click the \u2296 button next to any constraint to remove it.</p>"},{"location":"gui/simulation/","title":"Simulation","text":"<p>BLine-GUI includes a built-in simulation that previews how your robot will follow the path. This helps validate paths before deploying to hardware.</p> <p></p>"},{"location":"gui/simulation/#transport-controls","title":"Transport Controls","text":"<p>The simulation controls appear at the bottom-left of the canvas:</p> Control Function \u25b6 / \u23f8 Play/pause simulation Timeline slider Scrub through the path Time display Current time / total duration"},{"location":"gui/simulation/#playpause","title":"Play/Pause","text":"<p>Click the \u25b6 button or press Space to start the simulation. The robot icon will move along the path following the defined constraints.</p> <p>Click \u23f8 or press Space again to pause.</p>"},{"location":"gui/simulation/#timeline-scrubbing","title":"Timeline Scrubbing","text":"<p>Drag the timeline slider to jump to any point in the path. This lets you inspect specific moments without watching the entire simulation.</p>"},{"location":"gui/simulation/#time-display","title":"Time Display","text":"<p>The time display shows <code>current / total</code> in seconds, giving you the estimated path duration.</p>"},{"location":"gui/simulation/#visual-feedback","title":"Visual Feedback","text":"<p>During simulation, the canvas shows additional information:</p>"},{"location":"gui/simulation/#robot-position","title":"Robot Position","text":"<p>A robot icon shows the current simulated position and rotation. The icon rotates to match the robot's orientation.</p>"},{"location":"gui/simulation/#trajectory-trail","title":"Trajectory Trail","text":"<p>An orange trail shows the path the robot has traveled during the simulation. This helps visualize the actual trajectory versus the intended path.</p>"},{"location":"gui/simulation/#velocity-indication","title":"Velocity Indication","text":"<p>The robot icon's movement speed reflects the simulated velocity, giving you a sense of how constraints affect the robot's speed at different parts of the path.</p>"},{"location":"gui/simulation/#understanding-simulation-results","title":"Understanding Simulation Results","text":""},{"location":"gui/simulation/#what-the-simulation-shows","title":"What the Simulation Shows","text":"<ul> <li>Path timing: Estimated duration for the entire path</li> <li>Velocity profile: How fast the robot moves at each segment</li> <li>Trajectory shape: The actual path the robot follows</li> <li>Rotation behavior: How the robot rotates along the path</li> </ul>"},{"location":"gui/simulation/#what-the-simulation-doesnt-show","title":"What the Simulation Doesn't Show","text":"<p>Simulation Limitations</p> <p>The simulation uses idealistic kinematics and assumes the drivetrain responds instantly to commanded velocities. Key limitations:</p> <ul> <li>No PID simulation: Uses a simplified <code>v = \u221a(2ad)</code> formula instead of actual PID control</li> <li>No wheel slip: Assumes perfect traction</li> <li>No disturbances: No external forces or field interactions</li> <li>Instant acceleration: Doesn't model motor response time</li> </ul>"},{"location":"gui/simulation/#real-world-testing","title":"Real-World Testing","text":"<p>The simulation provides an initial visualization of your path, but for accurate results:</p> <ol> <li>Use a physics simulation framework like WPILib's simulation</li> <li>Test on actual hardware</li> <li>Iterate based on empirical results</li> </ol> <p>Rapid Iteration</p> <p>BLine is designed for rapid iteration. Use the GUI simulation for quick checks, then test on hardware. The fast path computation time means you can quickly adjust and re-test.</p>"},{"location":"gui/simulation/#tips-for-using-simulation","title":"Tips for Using Simulation","text":""},{"location":"gui/simulation/#check-constraint-effects","title":"Check Constraint Effects","text":"<p>Play the simulation while adjusting constraints to see how they affect:</p> <ul> <li>Overall path time</li> <li>Speed through different segments</li> <li>Smooth transitions between elements</li> </ul>"},{"location":"gui/simulation/#identify-problem-areas","title":"Identify Problem Areas","text":"<p>Watch for:</p> <ul> <li>Overshoot on corners: May indicate overly aggressive constraints or insufficient deceleration</li> <li>Sharp slowdowns: May indicate overly aggressive constraints</li> <li>Corner cutting: Handoff radius might be too large</li> <li>Hesitation: Handoff radius might be too small</li> <li>Unusual rotations: Check profiled rotation settings</li> </ul>"},{"location":"gui/simulation/#validate-path-order","title":"Validate Path Order","text":"<p>The simulation helps verify that elements are in the correct order and that the path flows as intended.</p>"},{"location":"gui/simulation/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Shortcut Action <code>Space</code> Play/pause simulation"},{"location":"lib/","title":"Library Overview","text":"<p>BLine-Lib is the Java library that powers path following on your FRC robot. It loads paths (from JSON or code), handles alliance flipping, and provides the path-following algorithm for holonomic drivetrains.</p>"},{"location":"lib/#key-features","title":"Key Features","text":"<ul> <li>Simple API: Minimal boilerplate to get paths running</li> <li>Flexible path definition: JSON files, code, or both</li> <li>Customizable constraints: Global defaults with per-path and per-segment overrides</li> <li>Rate-limited motion: Smooth velocity and acceleration control</li> </ul>"},{"location":"lib/#architecture","title":"Architecture","text":"<p>BLine-Lib follows a simple flow: Builder \u2192 Path \u2192 FollowPath</p> <ol> <li>Builder \u2014 Configure PID controllers, pose suppliers, and drive callbacks once</li> <li>Path \u2014 Define waypoints, translation targets, and rotation targets (from JSON or code)</li> <li>FollowPath \u2014 Execute path following as a WPILib Command with rate-limited motion</li> </ol>"},{"location":"lib/#tracking-algorithm","title":"Tracking Algorithm","text":"<p>The path tracking algorithm works by:</p> <ol> <li>Calculating command robot speed via a PID controller minimizing total path distance remaining</li> <li>Determining velocity direction by pointing toward the current translation target</li> <li>Advancing to the next target when within the handoff radius of the current one</li> <li>Applying cross-track correction to stay on the line between waypoints</li> <li>Interpolating rotation based on progress between rotation targets</li> <li>Applying rate limiting via <code>ChassisRateLimiter</code> to respect constraints</li> </ol> <p></p>"},{"location":"lib/#algorithm-robustness","title":"Algorithm Robustness","text":"<p>The BLine path tracking algorithm is robust in its response to sharp changes in positional data:</p> <ul> <li>Speed magnitude computation depends on distance to the path's end</li> <li>Velocity direction depends on the next available waypoint</li> <li>All values are acceleration-limited in 2D for smooth robot motion</li> <li>Chassis output remains stable even during erroneous odometry jitter</li> </ul> <p>Non-time-parameterized advantage: Unlike PathPlanner, BLine is not time-parameterized. The control cycle acts in a greedy fashion, making the response uniform regardless of path completion or \"lag\" behind an idealized path. There's no penalty for falling behind schedule\u2014the robot simply continues toward its target.</p>"},{"location":"lib/#installation","title":"Installation","text":"<p>See the Installation Guide for setup instructions.</p>"},{"location":"lib/#quick-example","title":"Quick Example","text":"<pre><code>import frc.robot.lib.BLine.*;\nimport edu.wpi.first.math.controller.PIDController;\n\n// 1. Set global constraints (once, at robot init)\nPath.setDefaultGlobalConstraints(new Path.DefaultGlobalConstraints(\n    4.5, 12.0, 540, 860, 0.03, 2.0, 0.2\n));\n\n// 2. Create a FollowPath builder\nFollowPath.Builder pathBuilder = new FollowPath.Builder(\n    driveSubsystem,\n    driveSubsystem::getPose,\n    driveSubsystem::getChassisSpeeds,\n    driveSubsystem::drive,\n    new PIDController(5.0, 0.0, 0.0),\n    new PIDController(3.0, 0.0, 0.0),\n    new PIDController(2.0, 0.0, 0.0)\n).withDefaultShouldFlip()\n .withPoseReset(driveSubsystem::resetPose);\n\n// 3. Load and follow a path\nPath myPath = new Path(\"myPathFile\");\nCommand followCommand = pathBuilder.build(myPath);\n</code></pre>"},{"location":"lib/#learn-more","title":"Learn More","text":"<ul> <li>Path Construction \u2014 Creating paths in code and JSON</li> <li>FollowPath Builder \u2014 Configuring the path follower</li> <li>API Reference \u2014 Complete API documentation</li> </ul>"},{"location":"lib/api-reference/","title":"API Reference","text":"<p>Complete reference for BLine-Lib classes and methods.</p> <p>For the full Javadoc, see the online documentation.</p>"},{"location":"lib/api-reference/#path-class","title":"Path Class","text":"<p>The <code>Path</code> class represents a sequence of path elements with optional constraints.</p>"},{"location":"lib/api-reference/#constructors","title":"Constructors","text":"<pre><code>// Load from JSON file (adds .json automatically)\nPath(String filename)\n\n// Create programmatically\nPath(PathElement... elements)\n\n// Create with custom constraints\nPath(PathConstraints constraints, PathElement... elements)\n</code></pre>"},{"location":"lib/api-reference/#static-methods","title":"Static Methods","text":"<pre><code>// Set global defaults for all paths\nstatic void setDefaultGlobalConstraints(DefaultGlobalConstraints constraints)\n</code></pre>"},{"location":"lib/api-reference/#instance-methods","title":"Instance Methods","text":"Method Returns Description <code>getStartPose()</code> <code>Pose2d</code> Starting pose for odometry reset <code>getInitialModuleDirection()</code> <code>Rotation2d</code> Direction modules should face at start <code>flip()</code> <code>void</code> Mirror path for opposite alliance <code>undoFlip()</code> <code>void</code> Revert alliance flip <code>getPathElementsWithConstraints()</code> <code>List&lt;...&gt;</code> Elements with resolved constraints"},{"location":"lib/api-reference/#pathwaypoint","title":"Path.Waypoint","text":"<p>A point with both position and rotation.</p>"},{"location":"lib/api-reference/#constructors_1","title":"Constructors","text":"<pre><code>// From Translation2d and Rotation2d\nWaypoint(Translation2d translation, Rotation2d rotation)\n\n// From Pose2d\nWaypoint(Pose2d pose)\n</code></pre>"},{"location":"lib/api-reference/#json-format","title":"JSON Format","text":"<pre><code>{\n    \"type\": \"waypoint\",\n    \"translation_target\": {\n        \"x_meters\": 1.0,\n        \"y_meters\": 1.0,\n        \"intermediate_handoff_radius_meters\": 0.2\n    },\n    \"rotation_target\": {\n        \"rotation_radians\": 0,\n        \"profiled_rotation\": true\n    }\n}\n</code></pre>"},{"location":"lib/api-reference/#pathtranslationtarget","title":"Path.TranslationTarget","text":"<p>A position-only target.</p>"},{"location":"lib/api-reference/#constructors_2","title":"Constructors","text":"<pre><code>// From Translation2d\nTranslationTarget(Translation2d translation)\n\n// From coordinates\nTranslationTarget(double x, double y)\n</code></pre>"},{"location":"lib/api-reference/#json-format_1","title":"JSON Format","text":"<pre><code>{\n    \"type\": \"translation\",\n    \"x_meters\": 2.5,\n    \"y_meters\": 2.0,\n    \"intermediate_handoff_radius_meters\": 0.2\n}\n</code></pre>"},{"location":"lib/api-reference/#pathrotationtarget","title":"Path.RotationTarget","text":"<p>A rotation-only target positioned along a segment.</p>"},{"location":"lib/api-reference/#constructors_3","title":"Constructors","text":"<pre><code>// With t_ratio for position along segment\nRotationTarget(Rotation2d rotation, double tRatio)\n</code></pre>"},{"location":"lib/api-reference/#json-format_2","title":"JSON Format","text":"<pre><code>{\n    \"type\": \"rotation\",\n    \"rotation_radians\": 1.57,\n    \"t_ratio\": 0.5,\n    \"profiled_rotation\": true\n}\n</code></pre>"},{"location":"lib/api-reference/#pathdefaultglobalconstraints","title":"Path.DefaultGlobalConstraints","text":"<p>Global constraint defaults for all paths.</p>"},{"location":"lib/api-reference/#constructor","title":"Constructor","text":"<pre><code>DefaultGlobalConstraints(\n    double maxVelocityMetersPerSec,\n    double maxAccelerationMetersPerSec2,\n    double maxVelocityDegPerSec,\n    double maxAccelerationDegPerSec2,\n    double endTranslationToleranceMeters,\n    double endRotationToleranceDeg,\n    double intermediateHandoffRadiusMeters\n)\n</code></pre>"},{"location":"lib/api-reference/#parameters","title":"Parameters","text":"Parameter Type Description <code>maxVelocityMetersPerSec</code> <code>double</code> Max translational velocity (m/s) <code>maxAccelerationMetersPerSec2</code> <code>double</code> Max translational acceleration (m/s\u00b2) <code>maxVelocityDegPerSec</code> <code>double</code> Max rotational velocity (deg/s) <code>maxAccelerationDegPerSec2</code> <code>double</code> Max rotational acceleration (deg/s\u00b2) <code>endTranslationToleranceMeters</code> <code>double</code> Final position tolerance (m) <code>endRotationToleranceDeg</code> <code>double</code> Final rotation tolerance (deg) <code>intermediateHandoffRadiusMeters</code> <code>double</code> Default handoff radius (m)"},{"location":"lib/api-reference/#pathpathconstraints","title":"Path.PathConstraints","text":"<p>Fluent builder for path-specific constraints.</p>"},{"location":"lib/api-reference/#methods","title":"Methods","text":"<p>All methods return <code>this</code> for chaining.</p> Method Parameter Description <code>setMaxVelocityMetersPerSec</code> <code>double</code> Set max translation velocity <code>setMaxAccelerationMetersPerSec2</code> <code>double</code> Set max translation acceleration <code>setMaxVelocityDegPerSec</code> <code>double</code> Set max rotation velocity <code>setMaxAccelerationDegPerSec2</code> <code>double</code> Set max rotation acceleration <code>setEndTranslationToleranceMeters</code> <code>double</code> Set end position tolerance <code>setEndRotationToleranceDeg</code> <code>double</code> Set end rotation tolerance"},{"location":"lib/api-reference/#ranged-constraints","title":"Ranged Constraints","text":"<p>For ranged constraints, pass <code>RangedConstraint</code> objects:</p> <pre><code>setMaxVelocityMetersPerSec(RangedConstraint... constraints)\n</code></pre>"},{"location":"lib/api-reference/#pathrangedconstraint","title":"Path.RangedConstraint","text":"<p>A constraint that applies to a range of ordinals.</p>"},{"location":"lib/api-reference/#constructor_1","title":"Constructor","text":"<pre><code>RangedConstraint(double value, int startOrdinal, int endOrdinal)\n</code></pre>"},{"location":"lib/api-reference/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>value</code> <code>double</code> The constraint value <code>startOrdinal</code> <code>int</code> First element index (inclusive) <code>endOrdinal</code> <code>int</code> Last element index (inclusive)"},{"location":"lib/api-reference/#followpathbuilder","title":"FollowPath.Builder","text":"<p>Builder for creating path-following commands.</p>"},{"location":"lib/api-reference/#constructor_2","title":"Constructor","text":"<pre><code>Builder(\n    SubsystemBase driveSubsystem,\n    Supplier&lt;Pose2d&gt; poseSupplier,\n    Supplier&lt;ChassisSpeeds&gt; speedsSupplier,\n    Consumer&lt;ChassisSpeeds&gt; speedsConsumer,\n    PIDController translationController,\n    PIDController rotationController,\n    PIDController crossTrackController\n)\n</code></pre>"},{"location":"lib/api-reference/#methods_1","title":"Methods","text":"Method Parameter Description <code>build</code> <code>Path</code> Create command for the specified path <code>withPoseReset</code> <code>Consumer&lt;Pose2d&gt;</code> Reset pose at path start <code>withDefaultShouldFlip</code> \u2014 Auto-flip based on alliance <code>withShouldFlip</code> <code>Supplier&lt;Boolean&gt;</code> Custom flip logic"},{"location":"lib/api-reference/#followpath-logging-hooks","title":"FollowPath Logging Hooks","text":"<p>Static logging hooks for streaming internal state during path execution.</p>"},{"location":"lib/api-reference/#static-methods_1","title":"Static Methods","text":"Method Parameter Description <code>setPoseLoggingConsumer</code> <code>Consumer&lt;Pair&lt;String, Pose2d&gt;&gt;</code> Pose logging hook <code>setTranslationListLoggingConsumer</code> <code>Consumer&lt;Pair&lt;String, Translation2d[]&gt;&gt;</code> Translation array logging hook <code>setDoubleLoggingConsumer</code> <code>Consumer&lt;Pair&lt;String, Double&gt;&gt;</code> Numeric logging hook <code>setBooleanLoggingConsumer</code> <code>Consumer&lt;Pair&lt;String, Boolean&gt;&gt;</code> Boolean logging hook"},{"location":"lib/api-reference/#configjson-format","title":"config.json Format","text":"<p>Global configuration file (<code>src/main/deploy/autos/config.json</code>):</p> <pre><code>{\n    \"default_max_velocity_meters_per_sec\": 4.5,\n    \"default_max_acceleration_meters_per_sec2\": 12.0,\n    \"default_max_velocity_deg_per_sec\": 540,\n    \"default_max_acceleration_deg_per_sec2\": 860,\n    \"default_end_translation_tolerance_meters\": 0.03,\n    \"default_end_rotation_tolerance_deg\": 2.0,\n    \"default_intermediate_handoff_radius_meters\": 0.2\n}\n</code></pre>"},{"location":"lib/api-reference/#path-json-format","title":"Path JSON Format","text":"<p>Complete path file format (<code>src/main/deploy/autos/paths/*.json</code>):</p> <pre><code>{\n    \"path_elements\": [\n        // Array of path elements (waypoint, translation, rotation)\n    ],\n    \"constraints\": {\n        \"max_velocity_meters_per_sec\": 4.5,\n        // Or ranged:\n        \"max_velocity_meters_per_sec\": [\n            { \"value\": 4.5, \"start_ordinal\": 0, \"end_ordinal\": 1 }\n        ],\n        \"max_acceleration_meters_per_sec2\": 12.0,\n        \"max_velocity_deg_per_sec\": 540,\n        \"max_acceleration_deg_per_sec2\": 860,\n        \"end_translation_tolerance_meters\": 0.03,\n        \"end_rotation_tolerance_deg\": 2.0\n    }\n}\n</code></pre>"},{"location":"lib/follow-path/","title":"FollowPath Builder","text":"<p>The <code>FollowPath.Builder</code> creates commands that execute path following. It's designed to be configured once and reused for all paths.</p>"},{"location":"lib/follow-path/#basic-setup","title":"Basic Setup","text":"<pre><code>import frc.robot.lib.BLine.*;\nimport edu.wpi.first.math.controller.PIDController;\n\nFollowPath.Builder pathBuilder = new FollowPath.Builder(\n    driveSubsystem,                      // Subsystem requirement\n    driveSubsystem::getPose,             // Current pose supplier\n    driveSubsystem::getChassisSpeeds,    // Current speeds supplier\n    driveSubsystem::drive,               // Drive consumer\n    new PIDController(5.0, 0.0, 0.0),    // Translation controller\n    new PIDController(3.0, 0.0, 0.0),    // Rotation controller\n    new PIDController(2.0, 0.0, 0.0)     // Cross-track controller\n);\n</code></pre>"},{"location":"lib/follow-path/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Description <code>driveSubsystem</code> <code>SubsystemBase</code> The drive subsystem to require <code>poseSupplier</code> <code>Supplier&lt;Pose2d&gt;</code> Returns current robot pose <code>speedsSupplier</code> <code>Supplier&lt;ChassisSpeeds&gt;</code> Returns current robot-relative speeds <code>speedsConsumer</code> <code>Consumer&lt;ChassisSpeeds&gt;</code> Accepts robot-relative speeds to drive <code>translationController</code> <code>PIDController</code> Controls speed based on distance remaining <code>rotationController</code> <code>PIDController</code> Controls holonomic rotation toward targets <code>crossTrackController</code> <code>PIDController</code> Minimizes deviation from path line"},{"location":"lib/follow-path/#pid-controllers","title":"PID Controllers","text":""},{"location":"lib/follow-path/#translation-controller","title":"Translation Controller","text":"<p>Controls the robot's speed based on remaining distance to the path end.</p> <ul> <li>Input: Distance remaining (meters)</li> <li>Output: Desired velocity (m/s)</li> <li>Tuning: Higher P = faster acceleration, but may overshoot</li> </ul> <pre><code>new PIDController(5.0, 0.0, 0.0)  // Typical starting point\n</code></pre>"},{"location":"lib/follow-path/#rotation-controller","title":"Rotation Controller","text":"<p>Controls the robot's holonomic rotation toward rotation targets.</p> <ul> <li>Input: rotation error (radians)</li> <li>Output: Desired angular velocity (rad/s)</li> <li>Tuning: Higher P = faster rotation response</li> </ul> <pre><code>new PIDController(3.0, 0.0, 0.0)  // Typical starting point\n</code></pre>"},{"location":"lib/follow-path/#cross-track-controller","title":"Cross-Track Controller","text":"<p>Minimizes deviation from the line between waypoints.</p> <ul> <li>Input: Perpendicular distance from path line (meters)</li> <li>Output: Correction velocity (m/s)</li> <li>Tuning: Higher P = stronger path adherence</li> </ul> <pre><code>new PIDController(2.0, 0.0, 0.0)  // Typical starting point\n</code></pre>"},{"location":"lib/follow-path/#how-the-controllers-work-together","title":"How the Controllers Work Together","text":"<p>The tracking control loop runs all three PID controllers each cycle:</p> <ol> <li>Translation controller \u2014 Minimizes total remaining path distance and drives the robot to the final path element</li> <li>Rotation controller \u2014 Either follows the profiled rotation setpoint or snaps directly to the target if no profile is specified</li> <li>Cross-Track Error (CTE) controller \u2014 Minimizes deviation from the line between current and previous path segments, helping reduce post-handoff cross-track error</li> </ol> <p>The translation controller's speed magnitude depends on distance to the path's end, while direction depends on the next available waypoint. These values are acceleration-limited in 2D to provide smooth robot motion toward the target, making chassis output relatively stable even during erroneous odometry jitter.</p>"},{"location":"lib/follow-path/#builder-methods","title":"Builder Methods","text":""},{"location":"lib/follow-path/#withposereset","title":"withPoseReset","text":"<p>Resets odometry to the path's starting pose when the command begins:</p> <pre><code>pathBuilder.withPoseReset(driveSubsystem::resetPose);\n</code></pre> <p>This is useful for the first path in autonomous to ensure odometry starts correctly.</p>"},{"location":"lib/follow-path/#withdefaultshouldflip","title":"withDefaultShouldFlip","text":"<p>Automatically flip paths for the red alliance based on <code>DriverStation.getAlliance()</code>:</p> <pre><code>pathBuilder.withDefaultShouldFlip();\n</code></pre>"},{"location":"lib/follow-path/#withshouldflip","title":"withShouldFlip","text":"<p>Custom flip logic:</p> <pre><code>pathBuilder.withShouldFlip(() -&gt; {\n    // Return true to flip the path\n    return DriverStation.getAlliance() == Alliance.Red;\n});\n</code></pre>"},{"location":"lib/follow-path/#building-commands","title":"Building Commands","text":"<p>Use <code>build()</code> to create a command for a specific path:</p> <pre><code>Path myPath = new Path(\"myPathFile\");\nCommand followCommand = pathBuilder.build(myPath);\n</code></pre> <p>The returned command:</p> <ul> <li>Requires the drive subsystem</li> <li>Runs until the robot reaches the end tolerances</li> <li>Stops the drivetrain when finished</li> </ul> <p>No Mid-Path Stopping</p> <p>BLine does not support stopping the robot midway through a path. If you need the robot to stop partway through, create separate Path objects and chain them together:</p> <pre><code>Commands.sequence(\n    pathBuilder.build(firstSegment),    // Drive to first location\n    new ScoreCommand(),                 // Stop and score\n    pathBuilder.build(secondSegment)    // Continue to next location\n);\n</code></pre>"},{"location":"lib/follow-path/#complete-example","title":"Complete Example","text":"<pre><code>public class RobotContainer {\n    private final DriveSubsystem driveSubsystem = new DriveSubsystem();\n    private final FollowPath.Builder pathBuilder;\n\n    public RobotContainer() {\n        // Set global constraints\n        Path.setDefaultGlobalConstraints(new Path.DefaultGlobalConstraints(\n            4.5, 12.0, 540, 860, 0.03, 2.0, 0.2\n        ));\n\n        // Create path builder\n        pathBuilder = new FollowPath.Builder(\n            driveSubsystem,\n            driveSubsystem::getPose,\n            driveSubsystem::getChassisSpeeds,\n            driveSubsystem::drive,\n            new PIDController(5.0, 0.0, 0.0),\n            new PIDController(3.0, 0.0, 0.0),\n            new PIDController(2.0, 0.0, 0.0)\n        ).withDefaultShouldFlip()\n         .withPoseReset(driveSubsystem::resetPose);\n    }\n\n    public Command getAutonomousCommand() {\n        return Commands.sequence(\n            pathBuilder.build(new Path(\"toFirstScore\")),\n            new ScoreCommand(),\n            pathBuilder.build(new Path(\"toPickup\")),\n            new IntakeCommand(),\n            pathBuilder.build(new Path(\"toSecondScore\")),\n            new ScoreCommand()\n        );\n    }\n}\n</code></pre>"},{"location":"lib/follow-path/#tuning-tips","title":"Tuning Tips","text":"<p>Tune at Maximum Velocities</p> <p>When tuning PID controllers, stress-test your gains at maximum robot velocity and acceleration. If you limit max acceleration after tuning, or increase max velocity beyond what was used during tuning, you will likely experience:</p> <ul> <li>Overshoot when reaching the path endpoint</li> <li>Unexpected behavior during path following</li> </ul> <p>Always tune within the full operating range of velocities and accelerations.</p>"},{"location":"lib/follow-path/#tuning-order","title":"Tuning Order","text":"<p>The PID controllers should be tuned in the following order: translation, rotation, and finally cross-track.</p>"},{"location":"lib/follow-path/#translation-controller_1","title":"Translation Controller","text":"<p>The translation controller minimizes total path distance remaining.</p> <p>Controller Instability</p> <p>Avoid using the PID integral term for the translation controller. Using the integral term will cause translation controller instability. Integral term use in other controllers (Rotation and Cross-Track) is fine.</p> <p>Starting gains: P = 5.0, I = 0.0, D = 0.0</p>"},{"location":"lib/follow-path/#rotation-controller_1","title":"Rotation Controller","text":"<p>Minimizes error in holonomic heading (rotation).</p> <p>Starting gains: P = 3.0, I = 0.0, D = 0.0</p>"},{"location":"lib/follow-path/#cross-track-controller_1","title":"Cross-Track Controller","text":"<p>Keeps the robot on the line between waypoints or translation targets. It should be used to reduce path deviation in longer path segments over time, rather than on sharp turns.</p> <p>Controller Instability</p> <p>Be wary of cross-track controller over-tuning (where the controller overpowers the translation controller). An over-tuned cross-track controller will cause undesirable behavior around turns, especially during high velocities.</p> <p>Starting gains: P = 2.0, I = 0.0, D = 0.0</p>"},{"location":"lib/logging/","title":"Logging","text":"<p><code>FollowPath</code> exposes optional static logging hooks so you can stream internal state to your logger (for example, AdvantageKit). Each hook receives a <code>Pair&lt;String, T&gt;</code> where the key identifies the metric and the value carries the data.</p>"},{"location":"lib/logging/#consumer-based-logging","title":"Consumer-Based Logging","text":"<p>Register any combination of the logging consumers before running commands:</p> <pre><code>FollowPath.setDoubleLoggingConsumer(pair -&gt; {\n    Logger.recordOutput(pair.getFirst(), pair.getSecond());\n});\n\nFollowPath.setBooleanLoggingConsumer(pair -&gt; {\n    Logger.recordOutput(pair.getFirst(), pair.getSecond());\n});\n\nFollowPath.setPoseLoggingConsumer(pair -&gt; {\n    Logger.recordOutput(pair.getFirst(), pair.getSecond());\n});\n\nFollowPath.setTranslationListLoggingConsumer(pair -&gt; {\n    Logger.recordOutput(pair.getFirst(), pair.getSecond());\n});\n</code></pre> <p>Common keys include:</p> <ul> <li><code>FollowPath/pathTranslations</code></li> <li><code>FollowPath/robotTranslations</code></li> <li><code>FollowPath/crossTrackError</code></li> <li><code>FollowPath/targetRotation</code></li> </ul>"},{"location":"lib/path-construction/","title":"Path Construction","text":"<p>BLine supports three ways to create paths: loading from JSON files, defining programmatically in code, or a hybrid approach.</p>"},{"location":"lib/path-construction/#loading-from-json","title":"Loading from JSON","text":"<p>The simplest approach when using BLine-GUI or hand-written JSON files.</p>"},{"location":"lib/path-construction/#basic-usage","title":"Basic Usage","text":"<pre><code>// Loads deploy/autos/paths/myPathFile.json\n// Note: .json extension is added automatically\nPath myPath = new Path(\"myPathFile\");\n</code></pre> <p>Paths are loaded from <code>src/main/deploy/autos/paths/</code> by default.</p>"},{"location":"lib/path-construction/#json-file-structure","title":"JSON File Structure","text":"<pre><code>{\n    \"path_elements\": [\n        {\n            \"type\": \"waypoint\",\n            \"translation_target\": {\n                \"x_meters\": 1.0,\n                \"y_meters\": 1.0,\n                \"intermediate_handoff_radius_meters\": 0.2\n            },\n            \"rotation_target\": {\n                \"rotation_radians\": 0,\n                \"profiled_rotation\": true\n            }\n        },\n        {\n            \"type\": \"translation\",\n            \"x_meters\": 2.5,\n            \"y_meters\": 2.0,\n            \"intermediate_handoff_radius_meters\": 0.2\n        },\n        {\n            \"type\": \"rotation\",\n            \"rotation_radians\": 1.57,\n            \"t_ratio\": 0.5,\n            \"profiled_rotation\": true\n        },\n        {\n            \"type\": \"waypoint\",\n            \"translation_target\": {\n                \"x_meters\": 3.0,\n                \"y_meters\": 1.0\n            },\n            \"rotation_target\": {\n                \"rotation_radians\": 3.14,\n                \"profiled_rotation\": true\n            }\n        }\n    ],\n    \"constraints\": {\n        \"max_velocity_meters_per_sec\": [\n            { \"value\": 4.5, \"start_ordinal\": 0, \"end_ordinal\": 1 },\n            { \"value\": 2.0, \"start_ordinal\": 2, \"end_ordinal\": 3 }\n        ],\n        \"max_acceleration_meters_per_sec2\": 12.0,\n        \"end_translation_tolerance_meters\": 0.03,\n        \"end_rotation_tolerance_deg\": 2.0\n    }\n}\n</code></pre>"},{"location":"lib/path-construction/#element-types-in-json","title":"Element Types in JSON","text":"WaypointTranslationTargetRotationTarget <pre><code>{\n    \"type\": \"waypoint\",\n    \"translation_target\": {\n        \"x_meters\": 1.0,\n        \"y_meters\": 1.0,\n        \"intermediate_handoff_radius_meters\": 0.2\n    },\n    \"rotation_target\": {\n        \"rotation_radians\": 0,\n        \"profiled_rotation\": true\n    }\n}\n</code></pre> <pre><code>{\n    \"type\": \"translation\",\n    \"x_meters\": 2.5,\n    \"y_meters\": 2.0,\n    \"intermediate_handoff_radius_meters\": 0.2\n}\n</code></pre> <pre><code>{\n    \"type\": \"rotation\",\n    \"rotation_radians\": 1.57,\n    \"t_ratio\": 0.5,\n    \"profiled_rotation\": true\n}\n</code></pre>"},{"location":"lib/path-construction/#defining-programmatically","title":"Defining Programmatically","text":"<p>For code-only workflows or dynamic path generation.</p>"},{"location":"lib/path-construction/#basic-path","title":"Basic Path","text":"<pre><code>Path myPath = new Path(\n    new Path.Waypoint(new Translation2d(1.0, 1.0), new Rotation2d(0)),\n    new Path.TranslationTarget(new Translation2d(2.0, 2.0)),\n    new Path.Waypoint(new Translation2d(3.0, 1.0), new Rotation2d(Math.PI))\n);\n</code></pre>"},{"location":"lib/path-construction/#path-elements","title":"Path Elements","text":""},{"location":"lib/path-construction/#waypoint","title":"Waypoint","text":"<p>Combined position and rotation target:</p> <pre><code>// From Translation2d and Rotation2d\nnew Path.Waypoint(new Translation2d(1.0, 1.0), new Rotation2d(0))\n\n// From Pose2d\nnew Path.Waypoint(new Pose2d(1.0, 1.0, new Rotation2d(0)))\n</code></pre>"},{"location":"lib/path-construction/#translationtarget","title":"TranslationTarget","text":"<p>Position-only target:</p> <pre><code>// From Translation2d\nnew Path.TranslationTarget(new Translation2d(2.0, 2.0))\n\n// From coordinates\nnew Path.TranslationTarget(2.0, 2.0)\n</code></pre>"},{"location":"lib/path-construction/#rotationtarget","title":"RotationTarget","text":"<p>Rotation-only target with position along segment:</p> <pre><code>// Rotation at midpoint of segment (t_ratio = 0.5)\nnew Path.RotationTarget(new Rotation2d(Math.PI / 2), 0.5)\n</code></pre>"},{"location":"lib/path-construction/#with-path-constraints","title":"With Path Constraints","text":"<pre><code>Path.PathConstraints constraints = new Path.PathConstraints()\n    .setMaxVelocityMetersPerSec(2.0)\n    .setMaxAccelerationMetersPerSec2(1.5)\n    .setMaxVelocityDegPerSec(180.0)\n    .setMaxAccelerationDegPerSec2(360.0)\n    .setEndTranslationToleranceMeters(0.02)\n    .setEndRotationToleranceDeg(1.0);\n\nPath slowPath = new Path(\n    constraints,\n    new Path.Waypoint(new Translation2d(1.0, 1.0), new Rotation2d(0)),\n    new Path.TranslationTarget(new Translation2d(2.0, 2.0)),\n    new Path.Waypoint(new Translation2d(3.0, 1.0), new Rotation2d(Math.PI))\n);\n</code></pre>"},{"location":"lib/path-construction/#with-ranged-constraints","title":"With Ranged Constraints","text":"<pre><code>Path.PathConstraints rangedConstraints = new Path.PathConstraints()\n    .setMaxVelocityMetersPerSec(\n        new Path.RangedConstraint(4.0, 0, 2),   // Fast for elements 0-2\n        new Path.RangedConstraint(1.5, 3, 5)    // Slow for elements 3-5\n    )\n    .setMaxAccelerationMetersPerSec2(3.0);\n\nPath variedPath = new Path(\n    rangedConstraints,\n    // ... elements ...\n);\n</code></pre>"},{"location":"lib/path-construction/#ordinal-indexing-for-ranged-constraints","title":"Ordinal Indexing for Ranged Constraints","text":"<p>Important: Separate Ordinal Counters</p> <p>Translation and rotation ordinals are tracked separately:</p> <ul> <li>Translation ordinal increments for each <code>TranslationTarget</code> and each <code>Waypoint</code></li> <li>Rotation ordinal increments for each <code>RotationTarget</code> and each <code>Waypoint</code></li> </ul> <p>This means a <code>Waypoint</code> (which contains both translation and rotation) increments both counters, while standalone <code>TranslationTarget</code> and <code>RotationTarget</code> elements only increment their respective counter.</p> <p>Example ordinal assignment:</p> Path Element Translation Ordinal Rotation Ordinal Waypoint (start) 0 0 TranslationTarget 1 \u2014 RotationTarget (t_ratio=0.5) \u2014 1 TranslationTarget 2 \u2014 Waypoint (end) 3 2 <p>When the path follower processes each element, it checks if any ranged constraint applies by testing:</p> <pre><code>startOrdinal &lt;= currentOrdinal &amp;&amp; endOrdinal &gt;= currentOrdinal\n</code></pre> <p>If a constraint matches, that value is used; otherwise, the global default is applied.</p>"},{"location":"lib/path-construction/#global-constraints","title":"Global Constraints","text":"<p>Set default constraints that apply to all paths when no path-specific constraint is set.</p>"},{"location":"lib/path-construction/#using-configjson","title":"Using config.json","text":"<p>Create <code>src/main/deploy/autos/config.json</code>:</p> <pre><code>{\n    \"default_max_velocity_meters_per_sec\": 4.5,\n    \"default_max_acceleration_meters_per_sec2\": 12.0,\n    \"default_max_velocity_deg_per_sec\": 540,\n    \"default_max_acceleration_deg_per_sec2\": 860,\n    \"default_end_translation_tolerance_meters\": 0.03,\n    \"default_end_rotation_tolerance_deg\": 2.0,\n    \"default_intermediate_handoff_radius_meters\": 0.2\n}\n</code></pre>"},{"location":"lib/path-construction/#in-code","title":"In Code","text":"<pre><code>Path.setDefaultGlobalConstraints(new Path.DefaultGlobalConstraints(\n    4.5,    // maxVelocityMetersPerSec\n    12.0,   // maxAccelerationMetersPerSec2\n    540,    // maxVelocityDegPerSec\n    860,    // maxAccelerationDegPerSec2\n    0.03,   // endTranslationToleranceMeters\n    2.0,    // endRotationToleranceDeg\n    0.2     // intermediateHandoffRadiusMeters\n));\n</code></pre>"},{"location":"lib/path-construction/#alliance-flipping","title":"Alliance Flipping","text":"<p>BLine automatically handles path mirroring for the opposite alliance.</p>"},{"location":"lib/path-construction/#automatic-flipping","title":"Automatic Flipping","text":"<p>When using <code>.withDefaultShouldFlip()</code> on your builder, paths are automatically flipped based on <code>DriverStation.getAlliance()</code>:</p> <pre><code>FollowPath.Builder pathBuilder = new FollowPath.Builder(...)\n    .withDefaultShouldFlip();  // Auto-flip for red alliance\n</code></pre>"},{"location":"lib/path-construction/#manual-flipping","title":"Manual Flipping","text":"<p>You can also flip paths manually:</p> <pre><code>Path myPath = new Path(\"myPathFile\");\n\n// Flip for opposite alliance\nmyPath.flip();\n\n// Undo the flip\nmyPath.undoFlip();\n</code></pre>"},{"location":"lib/path-construction/#custom-flip-logic","title":"Custom Flip Logic","text":"<p>For custom flip behavior:</p> <pre><code>FollowPath.Builder pathBuilder = new FollowPath.Builder(...)\n    .withShouldFlip(() -&gt; {\n        // Your custom logic\n        return DriverStation.getAlliance() == Alliance.Red;\n    });\n</code></pre>"},{"location":"lib/path-construction/#path-utilities","title":"Path Utilities","text":""},{"location":"lib/path-construction/#get-starting-pose","title":"Get Starting Pose","text":"<p>Useful for resetting odometry:</p> <pre><code>Path myPath = new Path(\"myPathFile\");\nPose2d startPose = myPath.getStartPose();\n</code></pre>"},{"location":"lib/path-construction/#get-initial-module-direction","title":"Get Initial Module Direction","text":"<p>Get the direction swerve modules should face at path start:</p> <pre><code>Rotation2d initialDirection = myPath.getInitialModuleDirection();\ndriveSubsystem.setModuleOrientations(initialDirection);\n</code></pre>"},{"location":"lib/path-construction/#single-element-paths","title":"Single-Element Paths","text":"<p>Paths can consist of just one Waypoint or TranslationTarget:</p> <pre><code>// Simple point-to-point move\nPath simpleMove = new Path(\n    new Path.Waypoint(new Translation2d(3.0, 2.0), new Rotation2d(0))\n);\n</code></pre> <p>Note</p> <p>A path with only a RotationTarget is invalid\u2014you need at least one translation element.</p>"},{"location":"lib/pre-match/","title":"Pre-Match Module Orientation","text":"<p>For optimal autonomous start, pre-orient swerve modules:</p> <pre><code>// During robot setup or auto init\nPath firstPath = new Path(\"firstAutoPath\");\nRotation2d initialDirection = firstPath.getInitialModuleDirection();\n\n// Orient modules before match starts\ndriveSubsystem.setModuleOrientations(initialDirection);\n</code></pre> <p>This prevents micro-deviations at auto start caused by modules rotating while driving.</p>"}]}